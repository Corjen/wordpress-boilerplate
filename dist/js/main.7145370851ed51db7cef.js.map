{"version":3,"sources":["webpack:///main.7145370851ed51db7cef.js","webpack:///./src/js/modules/FormValidation.js","webpack:///./src/js/main.js","webpack:///./~/hyperform/dist/hyperform.js","webpack:///./~/script-loader/addScript.js","webpack:///./~/hyperform/dist/hyperform.js?e801"],"names":["webpackJsonp","module","__webpack_exports__","__webpack_require__","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","__WEBPACK_IMPORTED_MODULE_0_script_loader_hyperform_dist_hyperform_js__","FormValidation","n","window","hyperform","inputs","document","querySelectorAll","concat","forEach","input","required","addEventListener","e","preventDefault","a","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0__modules_FormValidation__","exports","src","execScript","eval","call"],"mappings":"AAAAA,cAAc,IACP,CACA,CAED,SAAUC,EAAQC,EAAqBC,GAE7C,YAGA,SAASC,GAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAIG,GAAI,EAAGC,EAAOH,MAAMD,EAAIK,QAASF,EAAIH,EAAIK,OAAQF,IAAOC,EAAKD,GAAKH,EAAIG,EAAM,OAAOC,GAAe,MAAOH,OAAMK,KAAKN,GAFrK,GAAIO,GAA0ET,EAAoB,ICAjHU,GDCqGV,EAAoBW,EAAEF,GCD1G,WACrBG,OAAOC,UAAUD,OACjB,IAAME,GAASC,SAASC,iBAAiB,YACxCC,OAAAhB,EAAIa,IAAQI,QAAQ,SAAAC,GACfA,EAAMC,UACRD,EAAME,iBAAiB,UAAW,SAAAC,GAAA,MAAKA,GAAEC,sBAK/CxB,GAAAyB,EAAAnB,GDeO,CAED,SAAUP,EAAQC,EAAqBC,GAE7C,YACAyB,QAAOC,eAAe3B,EAAqB,cAAgB4B,UErC3D,IAAAC,GAAA5B,EAAA,IAQC,WACCA,EAAAK,EAAAuB,EAAAJ,SFyCK,CACA,CACA,CACA,CACA,CAED,SAAU1B,EAAQ+B,GGxDxB/B,EAAA+B,QAAA,8zoIH8DM,SAAU/B,EAAQ+B,GI1DxB/B,EAAA+B,QAAA,SAAAC,GACA,mBAAAC,YACAA,WAAAD,GAEAE,KAAAC,KAAA,KAAAH,KJsEM,SAAUhC,EAAQ+B,EAAS7B,GK9EjCA,EAAA,IAAAA,EAAA,QLmFG","file":"main.7145370851ed51db7cef.js","sourcesContent":["webpackJsonp([0],[\n/* 0 */,\n/* 1 */,\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_script_loader_hyperform_dist_hyperform_js__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_script_loader_hyperform_dist_hyperform_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_script_loader_hyperform_dist_hyperform_js__);\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * Form validation\n *\n * @since 1.0.0\n */\n\n\nvar FormValidation = function FormValidation() {\n  window.hyperform(window);\n  var inputs = document.querySelectorAll('input');[].concat(_toConsumableArray(inputs)).forEach(function (input) {\n    if (input.required) {\n      input.addEventListener('invalid', function (e) {\n        return e.preventDefault();\n      });\n    }\n  });\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (FormValidation);\n\n/***/ }),\n/* 3 */,\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__modules_FormValidation__ = __webpack_require__(2);\n/**\n * Main.js\n *\n * @since 1.0.0\n */\n\n(function IIFE() {\n  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__modules_FormValidation__[\"a\" /* default */])();\n})();\n\n/***/ }),\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"/*! hyperform.js.org */\\nvar hyperform = (function () {\\n                       'use strict';\\n\\n                       var registry = Object.create(null);\\n\\n                       /**\\n                        * run all actions registered for a hook\\n                        *\\n                        * Every action gets called with a state object as `this` argument and with the\\n                        * hook's call arguments as call arguments.\\n                        *\\n                        * @return mixed the returned value of the action calls or undefined\\n                        */\\n                       function call_hook(hook) {\\n                         var result;\\n                         var call_args = Array.prototype.slice.call(arguments, 1);\\n\\n                         if (hook in registry) {\\n                           result = registry[hook].reduce(function (args) {\\n\\n                             return function (previousResult, currentAction) {\\n                               var interimResult = currentAction.apply({\\n                                 state: previousResult,\\n                                 hook: hook\\n                               }, args);\\n                               return interimResult !== undefined ? interimResult : previousResult;\\n                             };\\n                           }(call_args), result);\\n                         }\\n\\n                         return result;\\n                       }\\n\\n                       /**\\n                        * Filter a value through hooked functions\\n                        *\\n                        * Allows for additional parameters:\\n                        * js> do_filter('foo', null, current_element)\\n                        */\\n                       function do_filter(hook, initial_value) {\\n                         var result = initial_value;\\n                         var call_args = Array.prototype.slice.call(arguments, 1);\\n\\n                         if (hook in registry) {\\n                           result = registry[hook].reduce(function (previousResult, currentAction) {\\n                             call_args[0] = previousResult;\\n                             var interimResult = currentAction.apply({\\n                               state: previousResult,\\n                               hook: hook\\n                             }, call_args);\\n                             return interimResult !== undefined ? interimResult : previousResult;\\n                           }, result);\\n                         }\\n\\n                         return result;\\n                       }\\n\\n                       /**\\n                        * remove an action again\\n                        */\\n                       function remove_hook(hook, action) {\\n                         if (hook in registry) {\\n                           for (var i = 0; i < registry[hook].length; i++) {\\n                             if (registry[hook][i] === action) {\\n                               registry[hook].splice(i, 1);\\n                               break;\\n                             }\\n                           }\\n                         }\\n                       }\\n                       /**\\n                        * add an action to a hook\\n                        */\\n                       function add_hook(hook, action, position) {\\n                         if (!(hook in registry)) {\\n                           registry[hook] = [];\\n                         }\\n                         if (position === undefined) {\\n                           position = registry[hook].length;\\n                         }\\n                         registry[hook].splice(position, 0, action);\\n                       }\\n\\n                       /**\\n                        * return either the data of a hook call or the result of action, if the\\n                        * former is undefined\\n                        *\\n                        * @return function a function wrapper around action\\n                        */\\n                       function return_hook_or (hook, action) {\\n                         return function () {\\n                           var data = call_hook(hook, Array.prototype.slice.call(arguments));\\n\\n                           if (data !== undefined) {\\n                             return data;\\n                           }\\n\\n                           return action.apply(this, arguments);\\n                         };\\n                       }\\n\\n                       /* the following code is borrowed from the WebComponents project, licensed\\n                        * under the BSD license. Source:\\n                        * <https://github.com/webcomponents/webcomponentsjs/blob/5283db1459fa2323e5bfc8b9b5cc1753ed85e3d0/src/WebComponents/dom.js#L53-L78>\\n                        */\\n                       // defaultPrevented is broken in IE.\\n                       // https://connect.microsoft.com/IE/feedback/details/790389/event-defaultprevented-returns-false-after-preventdefault-was-called\\n\\n                       var workingDefaultPrevented = function () {\\n                         var e = document.createEvent('Event');\\n                         e.initEvent('foo', true, true);\\n                         e.preventDefault();\\n                         return e.defaultPrevented;\\n                       }();\\n\\n                       if (!workingDefaultPrevented) {\\n                         (function () {\\n                           var origPreventDefault = window.Event.prototype.preventDefault;\\n                           window.Event.prototype.preventDefault = function () {\\n                             if (!this.cancelable) {\\n                               return;\\n                             }\\n\\n                             origPreventDefault.call(this);\\n\\n                             Object.defineProperty(this, 'defaultPrevented', {\\n                               get: function get() {\\n                                 return true;\\n                               },\\n                               configurable: true\\n                             });\\n                           };\\n                         })();\\n                       }\\n                       /* end of borrowed code */\\n\\n                       function create_event(name) {\\n                         var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n                         var _ref$bubbles = _ref.bubbles;\\n                         var bubbles = _ref$bubbles === undefined ? true : _ref$bubbles;\\n                         var _ref$cancelable = _ref.cancelable;\\n                         var cancelable = _ref$cancelable === undefined ? false : _ref$cancelable;\\n\\n                         var event = document.createEvent('Event');\\n                         event.initEvent(name, bubbles, cancelable);\\n                         return event;\\n                       }\\n\\n                       function trigger_event (element, event) {\\n                         var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\\n\\n                         var _ref2$bubbles = _ref2.bubbles;\\n                         var bubbles = _ref2$bubbles === undefined ? true : _ref2$bubbles;\\n                         var _ref2$cancelable = _ref2.cancelable;\\n                         var cancelable = _ref2$cancelable === undefined ? false : _ref2$cancelable;\\n                         var payload = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\\n\\n                         if (!(event instanceof window.Event)) {\\n                           event = create_event(event, { bubbles: bubbles, cancelable: cancelable });\\n                         }\\n\\n                         for (var key in payload) {\\n                           if (payload.hasOwnProperty(key)) {\\n                             event[key] = payload[key];\\n                           }\\n                         }\\n\\n                         element.dispatchEvent(event);\\n\\n                         return event;\\n                       }\\n\\n                       /* and datetime-local? Spec says “Nah!” */\\n\\n                       var dates = ['datetime', 'date', 'month', 'week', 'time'];\\n\\n                       var plain_numbers = ['number', 'range'];\\n\\n                       /* everything that returns something meaningful for valueAsNumber and\\n                        * can have the step attribute */\\n                       var numbers = dates.concat(plain_numbers, 'datetime-local');\\n\\n                       /* the spec says to only check those for syntax in validity.typeMismatch.\\n                        * ¯\\\\_(ツ)_/¯ */\\n                       var type_checked = ['email', 'url'];\\n\\n                       /* check these for validity.badInput */\\n                       var input_checked = ['email', 'date', 'month', 'week', 'time', 'datetime', 'datetime-local', 'number', 'range', 'color'];\\n\\n                       var text_types = ['text', 'search', 'tel', 'password'].concat(type_checked);\\n\\n                       /* input element types, that are candidates for the validation API.\\n                        * Missing from this set are: button, hidden, menu (from <button>), reset and\\n                        * the types for non-<input> elements. */\\n                       var validation_candidates = ['checkbox', 'color', 'file', 'image', 'radio', 'submit'].concat(numbers, text_types);\\n\\n                       /* all known types of <input> */\\n                       var inputs = ['button', 'hidden', 'reset'].concat(validation_candidates);\\n\\n                       /* apparently <select> and <textarea> have types of their own */\\n                       var non_inputs = ['select-one', 'select-multiple', 'textarea'];\\n\\n                       /* shim layer for the Element.matches method */\\n\\n                       var ep = window.Element.prototype;\\n                       var native_matches = ep.matches || ep.matchesSelector || ep.msMatchesSelector || ep.webkitMatchesSelector;\\n\\n                       function matches (element, selector) {\\n                                              return native_matches.call(element, selector);\\n                       }\\n\\n                       /**\\n                        * mark an object with a '__hyperform=true' property\\n                        *\\n                        * We use this to distinguish our properties from the native ones. Usage:\\n                        * js> mark(obj);\\n                        * js> assert(obj.__hyperform === true)\\n                        */\\n\\n                       function mark (obj) {\\n                         if (['object', 'function'].indexOf(typeof obj) > -1) {\\n                           delete obj.__hyperform;\\n                           Object.defineProperty(obj, '__hyperform', {\\n                             configurable: true,\\n                             enumerable: false,\\n                             value: true\\n                           });\\n                         }\\n\\n                         return obj;\\n                       }\\n\\n                       /**\\n                        * the internal storage for messages\\n                        */\\n                       var store = new WeakMap();\\n\\n                       /* jshint -W053 */\\n                       var message_store = {\\n                         set: function set(element, message) {\\n                           var is_custom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\\n\\n                           if (element instanceof window.HTMLFieldSetElement) {\\n                             var wrapped_form = get_wrapper(element);\\n                             if (wrapped_form && !wrapped_form.settings.extendFieldset) {\\n                               /* make this a no-op for <fieldset> in strict mode */\\n                               return message_store;\\n                             }\\n                           }\\n\\n                           if (typeof message === 'string') {\\n                             message = new String(message);\\n                           }\\n                           if (is_custom) {\\n                             message.is_custom = true;\\n                           }\\n                           mark(message);\\n                           store.set(element, message);\\n\\n                           /* allow the :invalid selector to match */\\n                           if ('_original_setCustomValidity' in element) {\\n                             element._original_setCustomValidity(message.toString());\\n                           }\\n\\n                           return message_store;\\n                         },\\n                         get: function get(element) {\\n                           var message = store.get(element);\\n                           if (message === undefined && '_original_validationMessage' in element) {\\n                             /* get the browser's validation message, if we have none. Maybe it\\n                              * knows more than we. */\\n                             message = new String(element._original_validationMessage);\\n                           }\\n                           return message ? message : new String('');\\n                         },\\n                         delete: function _delete(element) {\\n                           if ('_original_setCustomValidity' in element) {\\n                             element._original_setCustomValidity('');\\n                           }\\n                           return store.delete(element);\\n                         }\\n                       };\\n\\n                       /**\\n                        * counter that will be incremented with every call\\n                        *\\n                        * Will enforce uniqueness, as long as no more than 1 hyperform scripts\\n                        * are loaded. (In that case we still have the \\\"random\\\" part below.)\\n                        */\\n\\n                       var uid = 0;\\n\\n                       /**\\n                        * generate a random ID\\n                        *\\n                        * @see https://gist.github.com/gordonbrander/2230317\\n                        */\\n                       function generate_id () {\\n                         var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hf_';\\n\\n                         return prefix + uid++ + Math.random().toString(36).substr(2);\\n                       }\\n\\n                       var warningsCache = new WeakMap();\\n\\n                       var DefaultRenderer = {\\n\\n                         /**\\n                          * called when a warning should become visible\\n                          */\\n                         attachWarning: function attachWarning(warning, element) {\\n                           /* should also work, if element is last,\\n                            * http://stackoverflow.com/a/4793630/113195 */\\n                           element.parentNode.insertBefore(warning, element.nextSibling);\\n                         },\\n\\n                         /**\\n                          * called when a warning should vanish\\n                          */\\n                         detachWarning: function detachWarning(warning, element) {\\n                           warning.parentNode.removeChild(warning);\\n                         },\\n\\n                         /**\\n                          * called when feedback to an element's state should be handled\\n                          *\\n                          * i.e., showing and hiding warnings\\n                          */\\n                         showWarning: function showWarning(element) {\\n                           var sub_radio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n                           var msg = message_store.get(element).toString();\\n                           var warning = warningsCache.get(element);\\n\\n                           if (msg) {\\n                             if (!warning) {\\n                               var wrapper = get_wrapper(element);\\n                               warning = document.createElement('div');\\n                               warning.className = wrapper && wrapper.settings.classes.warning || 'hf-warning';\\n                               warning.id = generate_id();\\n                               warning.setAttribute('aria-live', 'polite');\\n                               warningsCache.set(element, warning);\\n                             }\\n\\n                             element.setAttribute('aria-errormessage', warning.id);\\n                             warning.textContent = msg;\\n                             Renderer.attachWarning(warning, element);\\n                           } else if (warning && warning.parentNode) {\\n                             element.removeAttribute('aria-errormessage');\\n                             Renderer.detachWarning(warning, element);\\n                           }\\n\\n                           if (!sub_radio && element.type === 'radio' && element.form) {\\n                             /* render warnings for all other same-name radios, too */\\n                             Array.prototype.filter.call(document.getElementsByName(element.name), function (radio) {\\n                               return radio.name === element.name && radio.form === element.form;\\n                             }).map(function (radio) {\\n                               return Renderer.showWarning(radio, 'sub_radio');\\n                             });\\n                           }\\n                         }\\n\\n                       };\\n\\n                       var Renderer = {\\n\\n                         attachWarning: DefaultRenderer.attachWarning,\\n                         detachWarning: DefaultRenderer.detachWarning,\\n                         showWarning: DefaultRenderer.showWarning,\\n\\n                         set: function set(renderer, action) {\\n                           if (renderer.indexOf('_') > -1) {\\n                             /* global console */\\n                             // TODO delete before next non-patch version\\n                             console.log('Renderer.set: please use camelCase names. ' + renderer + ' will be removed in the next non-patch release.');\\n                             renderer = renderer.replace(/_([a-z])/g, function (g) {\\n                               return g[1].toUpperCase();\\n                             });\\n                           }\\n                           if (!action) {\\n                             action = DefaultRenderer[renderer];\\n                           }\\n                           Renderer[renderer] = action;\\n                         }\\n\\n                       };\\n\\n                       /**\\n                        * check element's validity and report an error back to the user\\n                        */\\n                       function reportValidity(element) {\\n                         /* if this is a <form>, report validity of all child inputs */\\n                         if (element instanceof window.HTMLFormElement) {\\n                           return Array.prototype.map.call(element.elements, reportValidity).every(function (b) {\\n                             return b;\\n                           });\\n                         }\\n\\n                         /* we copy checkValidity() here, b/c we have to check if the \\\"invalid\\\"\\n                          * event was canceled. */\\n                         var valid = ValidityState(element).valid;\\n                         var event;\\n                         if (valid) {\\n                           var wrapped_form = get_wrapper(element);\\n                           if (wrapped_form && wrapped_form.settings.validEvent) {\\n                             event = trigger_event(element, 'valid', { cancelable: true });\\n                           }\\n                         } else {\\n                           event = trigger_event(element, 'invalid', { cancelable: true });\\n                         }\\n\\n                         if (!event || !event.defaultPrevented) {\\n                           Renderer.showWarning(element);\\n                         }\\n\\n                         return valid;\\n                       }\\n\\n                       /**\\n                        * submit a form, because `element` triggered it\\n                        *\\n                        * This method also dispatches a submit event on the form prior to the\\n                        * submission. The event contains the trigger element as `submittedVia`.\\n                        *\\n                        * If the element is a button with a name, the name=value pair will be added\\n                        * to the submitted data.\\n                        */\\n                       function submit_form_via(element) {\\n                         /* apparently, the submit event is not triggered in most browsers on\\n                          * the submit() method, so we do it manually here to model a natural\\n                          * submit as closely as possible.\\n                          * Now to the fun fact: If you trigger a submit event from a form, what\\n                          * do you think should happen?\\n                          * 1) the form will be automagically submitted by the browser, or\\n                          * 2) nothing.\\n                          * And as you already suspected, the correct answer is: both! Firefox\\n                          * opts for 1), Chrome for 2). Yay! */\\n                         var event_got_cancelled;\\n\\n                         var submit_event = create_event('submit', { cancelable: true });\\n                         /* force Firefox to not submit the form, then fake preventDefault() */\\n                         submit_event.preventDefault();\\n                         Object.defineProperty(submit_event, 'defaultPrevented', {\\n                           value: false,\\n                           writable: true\\n                         });\\n                         Object.defineProperty(submit_event, 'preventDefault', {\\n                           value: function value() {\\n                             return submit_event.defaultPrevented = event_got_cancelled = true;\\n                           },\\n                           writable: true\\n                         });\\n                         trigger_event(element.form, submit_event, {}, { submittedVia: element });\\n\\n                         if (!event_got_cancelled) {\\n                           add_submit_field(element);\\n                           window.HTMLFormElement.prototype.submit.call(element.form);\\n                           window.setTimeout(function () {\\n                             return remove_submit_field(element);\\n                           });\\n                         }\\n                       }\\n\\n                       /**\\n                        * if a submit button was clicked, add its name=value by means of a type=hidden\\n                        * input field\\n                        */\\n                       function add_submit_field(button) {\\n                         if (['image', 'submit'].indexOf(button.type) > -1 && button.name) {\\n                           var wrapper = get_wrapper(button.form) || {};\\n                           var submit_helper = wrapper.submit_helper;\\n                           if (submit_helper) {\\n                             if (submit_helper.parentNode) {\\n                               submit_helper.parentNode.removeChild(submit_helper);\\n                             }\\n                           } else {\\n                             submit_helper = document.createElement('input');\\n                             submit_helper.type = 'hidden';\\n                             wrapper.submit_helper = submit_helper;\\n                           }\\n                           submit_helper.name = button.name;\\n                           submit_helper.value = button.value;\\n                           button.form.appendChild(submit_helper);\\n                         }\\n                       }\\n\\n                       /**\\n                        * remove a possible helper input, that was added by `add_submit_field`\\n                        */\\n                       function remove_submit_field(button) {\\n                         if (['image', 'submit'].indexOf(button.type) > -1 && button.name) {\\n                           var wrapper = get_wrapper(button.form) || {};\\n                           var submit_helper = wrapper.submit_helper;\\n                           if (submit_helper && submit_helper.parentNode) {\\n                             submit_helper.parentNode.removeChild(submit_helper);\\n                           }\\n                         }\\n                       }\\n\\n                       /**\\n                        * check a form's validity and submit it\\n                        *\\n                        * The method triggers a cancellable `validate` event on the form. If the\\n                        * event is cancelled, form submission will be aborted, too.\\n                        *\\n                        * If the form is found to contain invalid fields, focus the first field.\\n                        */\\n                       function check(button) {\\n                         /* trigger a \\\"validate\\\" event on the form to be submitted */\\n                         var val_event = trigger_event(button.form, 'validate', { cancelable: true });\\n                         if (val_event.defaultPrevented) {\\n                           /* skip the whole submit thing, if the validation is canceled. A user\\n                            * can still call form.submit() afterwards. */\\n                           return;\\n                         }\\n\\n                         var valid = true;\\n                         var first_invalid;\\n                         Array.prototype.map.call(button.form.elements, function (element) {\\n                           if (!reportValidity(element)) {\\n                             valid = false;\\n                             if (!first_invalid && 'focus' in element) {\\n                               first_invalid = element;\\n                             }\\n                           }\\n                         });\\n\\n                         if (valid) {\\n                           submit_form_via(button);\\n                         } else if (first_invalid) {\\n                           /* focus the first invalid element, if validation went south */\\n                           first_invalid.focus();\\n                           /* tell the tale, if anyone wants to react to it */\\n                           trigger_event(button.form, 'forminvalid');\\n                         }\\n                       }\\n\\n                       /**\\n                        * test if node is a submit button\\n                        */\\n                       function is_submit_button(node) {\\n                         return (\\n                           /* must be an input or button element... */\\n                           (node.nodeName === 'INPUT' || node.nodeName === 'BUTTON') && (\\n\\n                           /* ...and have a submitting type */\\n                           node.type === 'image' || node.type === 'submit')\\n                         );\\n                       }\\n\\n                       /**\\n                        * test, if the click event would trigger a submit\\n                        */\\n                       function is_submitting_click(event, button) {\\n                         return (\\n                           /* prevented default: won't trigger a submit */\\n                           !event.defaultPrevented && (\\n\\n                           /* left button or middle button (submits in Chrome) */\\n                           !('button' in event) || event.button < 2) &&\\n\\n                           /* must be a submit button... */\\n                           is_submit_button(button) &&\\n\\n                           /* the button needs a form, that's going to be submitted */\\n                           button.form &&\\n\\n                           /* again, if the form should not be validated, we're out of the game */\\n                           !button.form.hasAttribute('novalidate')\\n                         );\\n                       }\\n\\n                       /**\\n                        * test, if the keypress event would trigger a submit\\n                        */\\n                       function is_submitting_keypress(event) {\\n                         return (\\n                           /* prevented default: won't trigger a submit */\\n                           !event.defaultPrevented && (\\n                           /* ...and <Enter> was pressed... */\\n                           event.keyCode === 13 &&\\n\\n                           /* ...on an <input> that is... */\\n                           event.target.nodeName === 'INPUT' &&\\n\\n                           /* ...a standard text input field (not checkbox, ...) */\\n                           text_types.indexOf(event.target.type) > -1 ||\\n                           /* or <Enter> or <Space> was pressed... */\\n                           (event.keyCode === 13 || event.keyCode === 32) &&\\n\\n                           /* ...on a submit button */\\n                           is_submit_button(event.target)) &&\\n\\n                           /* there's a form... */\\n                           event.target.form &&\\n\\n                           /* ...and the form allows validation */\\n                           !event.target.form.hasAttribute('novalidate')\\n                         );\\n                       }\\n\\n                       /**\\n                        * catch clicks to children of <button>s\\n                        */\\n                       function get_clicked_button(element) {\\n                         if (is_submit_button(element)) {\\n                           return element;\\n                         } else if (matches(element, 'button:not([type]) *, button[type=\\\"submit\\\"] *')) {\\n                           return get_clicked_button(element.parentNode);\\n                         } else {\\n                           return null;\\n                         }\\n                       }\\n\\n                       /**\\n                        * return event handler to catch explicit submission by click on a button\\n                        */\\n                       function get_click_handler() {\\n                         var ignore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n                         return function (event) {\\n                           var button = get_clicked_button(event.target);\\n                           if (button && is_submitting_click(event, button)) {\\n                             event.preventDefault();\\n                             if (ignore || button.hasAttribute('formnovalidate')) {\\n                               /* if validation should be ignored, we're not interested in any checks */\\n                               submit_form_via(button);\\n                             } else {\\n                               check(button);\\n                             }\\n                           }\\n                         };\\n                       }\\n                       var click_handler = get_click_handler();\\n                       var ignored_click_handler = get_click_handler(true);\\n\\n                       /**\\n                        * catch implicit submission by pressing <Enter> in some situations\\n                        */\\n                       function get_keypress_handler(ignore) {\\n                         return function keypress_handler(event) {\\n                           if (is_submitting_keypress(event)) {\\n                             event.preventDefault();\\n\\n                             var wrapper = get_wrapper(event.target.form) || { settings: {} };\\n                             if (wrapper.settings.preventImplicitSubmit) {\\n                               /* user doesn't want an implicit submit. Cancel here. */\\n                               return;\\n                             }\\n\\n                             /* check, that there is no submit button in the form. Otherwise\\n                             * that should be clicked. */\\n                             var el = event.target.form.elements.length;\\n                             var submit;\\n                             for (var i = 0; i < el; i++) {\\n                               if (['image', 'submit'].indexOf(event.target.form.elements[i].type) > -1) {\\n                                 submit = event.target.form.elements[i];\\n                                 break;\\n                               }\\n                             }\\n\\n                             if (submit) {\\n                               submit.click();\\n                             } else if (ignore) {\\n                               submit_form_via(event.target);\\n                             } else {\\n                               check(event.target);\\n                             }\\n                           }\\n                         };\\n                       }\\n                       var keypress_handler = get_keypress_handler();\\n                       var ignored_keypress_handler = get_keypress_handler(true);\\n\\n                       /**\\n                        * catch all relevant events _prior_ to a form being submitted\\n                        *\\n                        * @param bool ignore bypass validation, when an attempt to submit the\\n                        *                    form is detected. True, when the wrapper's revalidate\\n                        *                    setting is 'never'.\\n                        */\\n                       function catch_submit(listening_node) {\\n                         var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n                         if (ignore) {\\n                           listening_node.addEventListener('click', ignored_click_handler);\\n                           listening_node.addEventListener('keypress', ignored_keypress_handler);\\n                         } else {\\n                           listening_node.addEventListener('click', click_handler);\\n                           listening_node.addEventListener('keypress', keypress_handler);\\n                         }\\n                       }\\n\\n                       /**\\n                        * decommission the event listeners from catch_submit() again\\n                        */\\n                       function uncatch_submit(listening_node) {\\n                         listening_node.removeEventListener('click', ignored_click_handler);\\n                         listening_node.removeEventListener('keypress', ignored_keypress_handler);\\n                         listening_node.removeEventListener('click', click_handler);\\n                         listening_node.removeEventListener('keypress', keypress_handler);\\n                       }\\n\\n                       /**\\n                        * remove `property` from element and restore _original_property, if present\\n                        */\\n                       function uninstall_property (element, property) {\\n                         try {\\n                           delete element[property];\\n                         } catch (e) {\\n                           /* Safari <= 9 and PhantomJS will end up here :-( Nothing to do except\\n                            * warning */\\n                           var wrapper = get_wrapper(element);\\n                           if (wrapper && wrapper.settings.debug) {\\n                             /* global console */\\n                             console.log('[hyperform] cannot uninstall custom property ' + property);\\n                           }\\n                           return false;\\n                         }\\n\\n                         var original_descriptor = Object.getOwnPropertyDescriptor(element, '_original_' + property);\\n\\n                         if (original_descriptor) {\\n                           Object.defineProperty(element, property, original_descriptor);\\n                         }\\n                       }\\n\\n                       /**\\n                        * add `property` to an element\\n                        *\\n                        * js> installer(element, 'foo', { value: 'bar' });\\n                        * js> assert(element.foo === 'bar');\\n                        */\\n                       function install_property (element, property, descriptor) {\\n                         descriptor.configurable = true;\\n                         descriptor.enumerable = true;\\n                         if ('value' in descriptor) {\\n                           descriptor.writable = true;\\n                         }\\n\\n                         var original_descriptor = Object.getOwnPropertyDescriptor(element, property);\\n\\n                         if (original_descriptor) {\\n\\n                           if (original_descriptor.configurable === false) {\\n                             /* Safari <= 9 and PhantomJS will end up here :-( Nothing to do except\\n                              * warning */\\n                             var wrapper = get_wrapper(element);\\n                             if (wrapper && wrapper.settings.debug) {\\n                               /* global console */\\n                               console.log('[hyperform] cannot install custom property ' + property);\\n                             }\\n                             return false;\\n                           }\\n\\n                           /* we already installed that property... */\\n                           if (original_descriptor.get && original_descriptor.get.__hyperform || original_descriptor.value && original_descriptor.value.__hyperform) {\\n                             return;\\n                           }\\n\\n                           /* publish existing property under new name, if it's not from us */\\n                           Object.defineProperty(element, '_original_' + property, original_descriptor);\\n                         }\\n\\n                         delete element[property];\\n                         Object.defineProperty(element, property, descriptor);\\n\\n                         return true;\\n                       }\\n\\n                       function is_field (element) {\\n                               return element instanceof window.HTMLButtonElement || element instanceof window.HTMLInputElement || element instanceof window.HTMLSelectElement || element instanceof window.HTMLTextAreaElement || element instanceof window.HTMLFieldSetElement || element === window.HTMLButtonElement.prototype || element === window.HTMLInputElement.prototype || element === window.HTMLSelectElement.prototype || element === window.HTMLTextAreaElement.prototype || element === window.HTMLFieldSetElement.prototype;\\n                       }\\n\\n                       /**\\n                        * set a custom validity message or delete it with an empty string\\n                        */\\n                       function setCustomValidity(element, msg) {\\n                         message_store.set(element, msg, true);\\n                       }\\n\\n                       function sprintf (str) {\\n                         for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n                           args[_key - 1] = arguments[_key];\\n                         }\\n\\n                         var args_length = args.length;\\n                         var global_index = 0;\\n\\n                         return str.replace(/%([0-9]+\\\\$)?([sl])/g, function (match, position, type) {\\n                           var local_index = global_index;\\n                           if (position) {\\n                             local_index = Number(position.replace(/\\\\$$/, '')) - 1;\\n                           }\\n                           global_index += 1;\\n\\n                           var arg = '';\\n                           if (args_length > local_index) {\\n                             arg = args[local_index];\\n                           }\\n\\n                           if (arg instanceof Date || typeof arg === 'number' || arg instanceof Number) {\\n                             /* try getting a localized representation of dates and numbers, if the\\n                              * browser supports this */\\n                             if (type === 'l') {\\n                               arg = (arg.toLocaleString || arg.toString).call(arg);\\n                             } else {\\n                               arg = arg.toString();\\n                             }\\n                           }\\n\\n                           return arg;\\n                         });\\n                       }\\n\\n                       /* For a given date, get the ISO week number\\n                        *\\n                        * Source: http://stackoverflow.com/a/6117889/113195\\n                        *\\n                        * Based on information at:\\n                        *\\n                        *    http://www.merlyn.demon.co.uk/weekcalc.htm#WNR\\n                        *\\n                        * Algorithm is to find nearest thursday, it's year\\n                        * is the year of the week number. Then get weeks\\n                        * between that date and the first day of that year.\\n                        *\\n                        * Note that dates in one year can be weeks of previous\\n                        * or next year, overlap is up to 3 days.\\n                        *\\n                        * e.g. 2014/12/29 is Monday in week  1 of 2015\\n                        *      2012/1/1   is Sunday in week 52 of 2011\\n                        */\\n\\n                       function get_week_of_year (d) {\\n                         /* Copy date so don't modify original */\\n                         d = new Date(+d);\\n                         d.setUTCHours(0, 0, 0);\\n                         /* Set to nearest Thursday: current date + 4 - current day number\\n                          * Make Sunday's day number 7 */\\n                         d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));\\n                         /* Get first day of year */\\n                         var yearStart = new Date(d.getUTCFullYear(), 0, 1);\\n                         /* Calculate full weeks to nearest Thursday */\\n                         var weekNo = Math.ceil(((d - yearStart) / 86400000 + 1) / 7);\\n                         /* Return array of year and week number */\\n                         return [d.getUTCFullYear(), weekNo];\\n                       }\\n\\n                       function pad(num) {\\n                         var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\\n\\n                         var s = num + '';\\n                         while (s.length < size) {\\n                           s = '0' + s;\\n                         }\\n                         return s;\\n                       }\\n\\n                       /**\\n                        * calculate a string from a date according to HTML5\\n                        */\\n                       function date_to_string(date, element_type) {\\n                         if (!(date instanceof Date)) {\\n                           return null;\\n                         }\\n\\n                         switch (element_type) {\\n                           case 'datetime':\\n                             return date_to_string(date, 'date') + 'T' + date_to_string(date, 'time');\\n\\n                           case 'datetime-local':\\n                             return sprintf('%s-%s-%sT%s:%s:%s.%s', date.getFullYear(), pad(date.getMonth() + 1), pad(date.getDate()), pad(date.getHours()), pad(date.getMinutes()), pad(date.getSeconds()), pad(date.getMilliseconds(), 3)).replace(/(:00)?\\\\.000$/, '');\\n\\n                           case 'date':\\n                             return sprintf('%s-%s-%s', date.getUTCFullYear(), pad(date.getUTCMonth() + 1), pad(date.getUTCDate()));\\n\\n                           case 'month':\\n                             return sprintf('%s-%s', date.getUTCFullYear(), pad(date.getUTCMonth() + 1));\\n\\n                           case 'week':\\n                             var params = get_week_of_year(date);\\n                             return sprintf.call(null, '%s-W%s', params[0], pad(params[1]));\\n\\n                           case 'time':\\n                             return sprintf('%s:%s:%s.%s', pad(date.getUTCHours()), pad(date.getUTCMinutes()), pad(date.getUTCSeconds()), pad(date.getUTCMilliseconds(), 3)).replace(/(:00)?\\\\.000$/, '');\\n                         }\\n\\n                         return null;\\n                       }\\n\\n                       /**\\n                        * return a new Date() representing the ISO date for a week number\\n                        *\\n                        * @see http://stackoverflow.com/a/16591175/113195\\n                        */\\n\\n                       function get_date_from_week (week, year) {\\n                         var date = new Date(Date.UTC(year, 0, 1 + (week - 1) * 7));\\n\\n                         if (date.getUTCDay() <= 4 /* thursday */) {\\n                             date.setUTCDate(date.getUTCDate() - date.getUTCDay() + 1);\\n                           } else {\\n                           date.setUTCDate(date.getUTCDate() + 8 - date.getUTCDay());\\n                         }\\n\\n                         return date;\\n                       }\\n\\n                       /**\\n                        * calculate a date from a string according to HTML5\\n                        */\\n                       function string_to_date (string, element_type) {\\n                         var date = new Date(0);\\n                         var ms;\\n                         switch (element_type) {\\n                           case 'datetime':\\n                             if (!/^([0-9]{4,})-([0-9]{2})-([0-9]{2})T([01][0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9])(?:\\\\.([0-9]{1,3}))?)?$/.test(string)) {\\n                               return null;\\n                             }\\n                             ms = RegExp.$7 || '000';\\n                             while (ms.length < 3) {\\n                               ms += '0';\\n                             }\\n                             date.setUTCFullYear(Number(RegExp.$1));\\n                             date.setUTCMonth(Number(RegExp.$2) - 1, Number(RegExp.$3));\\n                             date.setUTCHours(Number(RegExp.$4), Number(RegExp.$5), Number(RegExp.$6 || 0), Number(ms));\\n                             return date;\\n\\n                           case 'date':\\n                             if (!/^([0-9]{4,})-([0-9]{2})-([0-9]{2})$/.test(string)) {\\n                               return null;\\n                             }\\n                             date.setUTCFullYear(Number(RegExp.$1));\\n                             date.setUTCMonth(Number(RegExp.$2) - 1, Number(RegExp.$3));\\n                             return date;\\n\\n                           case 'month':\\n                             if (!/^([0-9]{4,})-([0-9]{2})$/.test(string)) {\\n                               return null;\\n                             }\\n                             date.setUTCFullYear(Number(RegExp.$1));\\n                             date.setUTCMonth(Number(RegExp.$2) - 1, 1);\\n                             return date;\\n\\n                           case 'week':\\n                             if (!/^([0-9]{4,})-W(0[1-9]|[1234][0-9]|5[0-3])$/.test(string)) {\\n                               return null;\\n                             }\\n                             return get_date_from_week(Number(RegExp.$2), Number(RegExp.$1));\\n\\n                           case 'time':\\n                             if (!/^([01][0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9])(?:\\\\.([0-9]{1,3}))?)?$/.test(string)) {\\n                               return null;\\n                             }\\n                             ms = RegExp.$4 || '000';\\n                             while (ms.length < 3) {\\n                               ms += '0';\\n                             }\\n                             date.setUTCHours(Number(RegExp.$1), Number(RegExp.$2), Number(RegExp.$3 || 0), Number(ms));\\n                             return date;\\n                         }\\n\\n                         return null;\\n                       }\\n\\n                       /**\\n                        * calculate a date from a string according to HTML5\\n                        */\\n                       function string_to_number (string, element_type) {\\n                         var rval = string_to_date(string, element_type);\\n                         if (rval !== null) {\\n                           return +rval;\\n                         }\\n                         /* not parseFloat, because we want NaN for invalid values like \\\"1.2xxy\\\" */\\n                         return Number(string);\\n                       }\\n\\n                       /**\\n                        * get the element's type in a backwards-compatible way\\n                        */\\n                       function get_type (element) {\\n                         if (element instanceof window.HTMLTextAreaElement) {\\n                           return 'textarea';\\n                         } else if (element instanceof window.HTMLSelectElement) {\\n                           return element.hasAttribute('multiple') ? 'select-multiple' : 'select-one';\\n                         } else if (element instanceof window.HTMLButtonElement) {\\n                           return (element.getAttribute('type') || 'submit').toLowerCase();\\n                         } else if (element instanceof window.HTMLInputElement) {\\n                           var attr = (element.getAttribute('type') || '').toLowerCase();\\n                           if (attr && inputs.indexOf(attr) > -1) {\\n                             return attr;\\n                           } else {\\n                             /* perhaps the DOM has in-depth knowledge. Take that before returning\\n                              * 'text'. */\\n                             return element.type || 'text';\\n                           }\\n                         }\\n\\n                         return '';\\n                       }\\n\\n                       /**\\n                        * the following validation messages are from Firefox source,\\n                        * http://mxr.mozilla.org/mozilla-central/source/dom/locales/en-US/chrome/dom/dom.properties\\n                        * released under MPL license, http://mozilla.org/MPL/2.0/.\\n                        */\\n\\n                       var catalog = {\\n                         en: {\\n                           TextTooLong: 'Please shorten this text to %l characters or less (you are currently using %l characters).',\\n                           ValueMissing: 'Please fill out this field.',\\n                           CheckboxMissing: 'Please check this box if you want to proceed.',\\n                           RadioMissing: 'Please select one of these options.',\\n                           FileMissing: 'Please select a file.',\\n                           SelectMissing: 'Please select an item in the list.',\\n                           InvalidEmail: 'Please enter an email address.',\\n                           InvalidURL: 'Please enter a URL.',\\n                           PatternMismatch: 'Please match the requested format.',\\n                           PatternMismatchWithTitle: 'Please match the requested format: %l.',\\n                           NumberRangeOverflow: 'Please select a value that is no more than %l.',\\n                           DateRangeOverflow: 'Please select a value that is no later than %l.',\\n                           TimeRangeOverflow: 'Please select a value that is no later than %l.',\\n                           NumberRangeUnderflow: 'Please select a value that is no less than %l.',\\n                           DateRangeUnderflow: 'Please select a value that is no earlier than %l.',\\n                           TimeRangeUnderflow: 'Please select a value that is no earlier than %l.',\\n                           StepMismatch: 'Please select a valid value. The two nearest valid values are %l and %l.',\\n                           StepMismatchOneValue: 'Please select a valid value. The nearest valid value is %l.',\\n                           BadInputNumber: 'Please enter a number.'\\n                         }\\n                       };\\n\\n                       /**\\n                        * the global language Hyperform will use\\n                        */\\n                       var language = 'en';\\n\\n                       /**\\n                        * set the language for Hyperform’s messages\\n                        */\\n                       function set_language(newlang) {\\n                         language = newlang;\\n                       }\\n\\n                       /**\\n                        * add a lookup catalog \\\"string: translation\\\" for a language\\n                        */\\n                       function add_translation(lang, new_catalog) {\\n                         if (!(lang in catalog)) {\\n                           catalog[lang] = {};\\n                         }\\n                         for (var key in new_catalog) {\\n                           if (new_catalog.hasOwnProperty(key)) {\\n                             catalog[lang][key] = new_catalog[key];\\n                           }\\n                         }\\n                       }\\n\\n                       /**\\n                        * return `s` translated into the current language\\n                        *\\n                        * Defaults to English if the former has no translation for `s`.\\n                        */\\n                       function _ (s) {\\n                         if (language in catalog && s in catalog[language]) {\\n                           return catalog[language][s];\\n                         } else if (s in catalog.en) {\\n                           return catalog.en[s];\\n                         }\\n                         return s;\\n                       }\\n\\n                       var default_step = {\\n                         'datetime-local': 60,\\n                         datetime: 60,\\n                         time: 60\\n                       };\\n\\n                       var step_scale_factor = {\\n                         'datetime-local': 1000,\\n                         datetime: 1000,\\n                         date: 86400000,\\n                         week: 604800000,\\n                         time: 1000\\n                       };\\n\\n                       var default_step_base = {\\n                         week: -259200000\\n                       };\\n\\n                       var default_min = {\\n                         range: 0\\n                       };\\n\\n                       var default_max = {\\n                         range: 100\\n                       };\\n\\n                       /**\\n                        * get previous and next valid values for a stepped input element\\n                        */\\n                       function get_next_valid (element) {\\n                         var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n                         var type = get_type(element);\\n\\n                         var aMin = element.getAttribute('min');\\n                         var min = default_min[type] || NaN;\\n                         if (aMin) {\\n                           var pMin = string_to_number(aMin, type);\\n                           if (!isNaN(pMin)) {\\n                             min = pMin;\\n                           }\\n                         }\\n\\n                         var aMax = element.getAttribute('max');\\n                         var max = default_max[type] || NaN;\\n                         if (aMax) {\\n                           var pMax = string_to_number(aMax, type);\\n                           if (!isNaN(pMax)) {\\n                             max = pMax;\\n                           }\\n                         }\\n\\n                         var aStep = element.getAttribute('step');\\n                         var step = default_step[type] || 1;\\n                         if (aStep && aStep.toLowerCase() === 'any') {\\n                           /* quick return: we cannot calculate prev and next */\\n                           return [_('any value'), _('any value')];\\n                         } else if (aStep) {\\n                           var pStep = string_to_number(aStep, type);\\n                           if (!isNaN(pStep)) {\\n                             step = pStep;\\n                           }\\n                         }\\n\\n                         var default_value = string_to_number(element.getAttribute('value'), type);\\n\\n                         var value = string_to_number(element.value || element.getAttribute('value'), type);\\n\\n                         if (isNaN(value)) {\\n                           /* quick return: we cannot calculate without a solid base */\\n                           return [_('any valid value'), _('any valid value')];\\n                         }\\n\\n                         var step_base = !isNaN(min) ? min : !isNaN(default_value) ? default_value : default_step_base[type] || 0;\\n\\n                         var scale = step_scale_factor[type] || 1;\\n\\n                         var prev = step_base + Math.floor((value - step_base) / (step * scale)) * (step * scale) * n;\\n                         var next = step_base + (Math.floor((value - step_base) / (step * scale)) + 1) * (step * scale) * n;\\n\\n                         if (prev < min) {\\n                           prev = null;\\n                         } else if (prev > max) {\\n                           prev = max;\\n                         }\\n\\n                         if (next > max) {\\n                           next = null;\\n                         } else if (next < min) {\\n                           next = min;\\n                         }\\n\\n                         /* convert to date objects, if appropriate */\\n                         if (dates.indexOf(type) > -1) {\\n                           prev = date_to_string(new Date(prev), type);\\n                           next = date_to_string(new Date(next), type);\\n                         }\\n\\n                         return [prev, next];\\n                       }\\n\\n                       /**\\n                        * implement the valueAsDate functionality\\n                        *\\n                        * @see https://html.spec.whatwg.org/multipage/forms.html#dom-input-valueasdate\\n                        */\\n                       function valueAsDate(element) {\\n                         var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\\n\\n                         var type = get_type(element);\\n                         if (dates.indexOf(type) > -1) {\\n                           if (value !== undefined) {\\n                             /* setter: value must be null or a Date() */\\n                             if (value === null) {\\n                               element.value = '';\\n                             } else if (value instanceof Date) {\\n                               if (isNaN(value.getTime())) {\\n                                 element.value = '';\\n                               } else {\\n                                 element.value = date_to_string(value, type);\\n                               }\\n                             } else {\\n                               throw new window.DOMException('valueAsDate setter encountered invalid value', 'TypeError');\\n                             }\\n                             return;\\n                           }\\n\\n                           var value_date = string_to_date(element.value, type);\\n                           return value_date instanceof Date ? value_date : null;\\n                         } else if (value !== undefined) {\\n                           /* trying to set a date on a not-date input fails */\\n                           throw new window.DOMException('valueAsDate setter cannot set date on this element', 'InvalidStateError');\\n                         }\\n\\n                         return null;\\n                       }\\n\\n                       /**\\n                        * implement the valueAsNumber functionality\\n                        *\\n                        * @see https://html.spec.whatwg.org/multipage/forms.html#dom-input-valueasnumber\\n                        */\\n                       function valueAsNumber(element) {\\n                         var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\\n\\n                         var type = get_type(element);\\n                         if (numbers.indexOf(type) > -1) {\\n                           if (type === 'range' && element.hasAttribute('multiple')) {\\n                             /* @see https://html.spec.whatwg.org/multipage/forms.html#do-not-apply */\\n                             return NaN;\\n                           }\\n\\n                           if (value !== undefined) {\\n                             /* setter: value must be NaN or a finite number */\\n                             if (isNaN(value)) {\\n                               element.value = '';\\n                             } else if (typeof value === 'number' && window.isFinite(value)) {\\n                               try {\\n                                 /* try setting as a date, but... */\\n                                 valueAsDate(element, new Date(value));\\n                               } catch (e) {\\n                                 /* ... when valueAsDate is not responsible, ... */\\n                                 if (!(e instanceof window.DOMException)) {\\n                                   throw e;\\n                                 }\\n                                 /* ... set it via Number.toString(). */\\n                                 element.value = value.toString();\\n                               }\\n                             } else {\\n                               throw new window.DOMException('valueAsNumber setter encountered invalid value', 'TypeError');\\n                             }\\n                             return;\\n                           }\\n\\n                           return string_to_number(element.value, type);\\n                         } else if (value !== undefined) {\\n                           /* trying to set a number on a not-number input fails */\\n                           throw new window.DOMException('valueAsNumber setter cannot set number on this element', 'InvalidStateError');\\n                         }\\n\\n                         return NaN;\\n                       }\\n\\n                       /**\\n                        *\\n                        */\\n                       function stepDown(element) {\\n                         var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n                         if (numbers.indexOf(get_type(element)) === -1) {\\n                           throw new window.DOMException('stepDown encountered invalid type', 'InvalidStateError');\\n                         }\\n                         if ((element.getAttribute('step') || '').toLowerCase() === 'any') {\\n                           throw new window.DOMException('stepDown encountered step \\\"any\\\"', 'InvalidStateError');\\n                         }\\n\\n                         var prev = get_next_valid(element, n)[0];\\n\\n                         if (prev !== null) {\\n                           valueAsNumber(element, prev);\\n                         }\\n                       }\\n\\n                       /**\\n                        *\\n                        */\\n                       function stepUp(element) {\\n                         var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n                         if (numbers.indexOf(get_type(element)) === -1) {\\n                           throw new window.DOMException('stepUp encountered invalid type', 'InvalidStateError');\\n                         }\\n                         if ((element.getAttribute('step') || '').toLowerCase() === 'any') {\\n                           throw new window.DOMException('stepUp encountered step \\\"any\\\"', 'InvalidStateError');\\n                         }\\n\\n                         var next = get_next_valid(element, n)[1];\\n\\n                         if (next !== null) {\\n                           valueAsNumber(element, next);\\n                         }\\n                       }\\n\\n                       /**\\n                        * get the validation message for an element, empty string, if the element\\n                        * satisfies all constraints.\\n                        */\\n                       function validationMessage(element) {\\n                         var msg = message_store.get(element);\\n                         if (!msg) {\\n                           return '';\\n                         }\\n\\n                         /* make it a primitive again, since message_store returns String(). */\\n                         return msg.toString();\\n                       }\\n\\n                       /**\\n                        * check, if an element will be subject to HTML5 validation at all\\n                        */\\n                       function willValidate(element) {\\n                         return is_validation_candidate(element);\\n                       }\\n\\n                       var gA = function gA(prop) {\\n                         return function () {\\n                           return do_filter('attr_get_' + prop, this.getAttribute(prop), this);\\n                         };\\n                       };\\n\\n                       var sA = function sA(prop) {\\n                         return function (value) {\\n                           this.setAttribute(prop, do_filter('attr_set_' + prop, value, this));\\n                         };\\n                       };\\n\\n                       var gAb = function gAb(prop) {\\n                         return function () {\\n                           return do_filter('attr_get_' + prop, this.hasAttribute(prop), this);\\n                         };\\n                       };\\n\\n                       var sAb = function sAb(prop) {\\n                         return function (value) {\\n                           if (do_filter('attr_set_' + prop, value, this)) {\\n                             this.setAttribute(prop, prop);\\n                           } else {\\n                             this.removeAttribute(prop);\\n                           }\\n                         };\\n                       };\\n\\n                       var gAn = function gAn(prop) {\\n                         return function () {\\n                           return do_filter('attr_get_' + prop, Math.max(0, Number(this.getAttribute(prop))), this);\\n                         };\\n                       };\\n\\n                       var sAn = function sAn(prop) {\\n                         return function (value) {\\n                           value = do_filter('attr_set_' + prop, value, this);\\n                           if (/^[0-9]+$/.test(value)) {\\n                             this.setAttribute(prop, value);\\n                           }\\n                         };\\n                       };\\n\\n                       function install_properties(element) {\\n                         var _arr = ['accept', 'max', 'min', 'pattern', 'placeholder', 'step'];\\n\\n                         for (var _i = 0; _i < _arr.length; _i++) {\\n                           var prop = _arr[_i];\\n                           install_property(element, prop, {\\n                             get: gA(prop),\\n                             set: sA(prop)\\n                           });\\n                         }\\n\\n                         var _arr2 = ['multiple', 'required', 'readOnly'];\\n                         for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\\n                           var _prop = _arr2[_i2];\\n                           install_property(element, _prop, {\\n                             get: gAb(_prop.toLowerCase()),\\n                             set: sAb(_prop.toLowerCase())\\n                           });\\n                         }\\n\\n                         var _arr3 = ['minLength', 'maxLength'];\\n                         for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\\n                           var _prop2 = _arr3[_i3];\\n                           install_property(element, _prop2, {\\n                             get: gAn(_prop2.toLowerCase()),\\n                             set: sAn(_prop2.toLowerCase())\\n                           });\\n                         }\\n                       }\\n\\n                       function uninstall_properties(element) {\\n                         var _arr4 = ['accept', 'max', 'min', 'pattern', 'placeholder', 'step', 'multiple', 'required', 'readOnly', 'minLength', 'maxLength'];\\n\\n                         for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\\n                           var prop = _arr4[_i4];\\n                           uninstall_property(element, prop);\\n                         }\\n                       }\\n\\n                       var polyfills = {\\n                         checkValidity: {\\n                           value: mark(function () {\\n                             return checkValidity(this);\\n                           })\\n                         },\\n                         reportValidity: {\\n                           value: mark(function () {\\n                             return reportValidity(this);\\n                           })\\n                         },\\n                         setCustomValidity: {\\n                           value: mark(function (msg) {\\n                             return setCustomValidity(this, msg);\\n                           })\\n                         },\\n                         stepDown: {\\n                           value: mark(function () {\\n                             var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n                             return stepDown(this, n);\\n                           })\\n                         },\\n                         stepUp: {\\n                           value: mark(function () {\\n                             var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n                             return stepUp(this, n);\\n                           })\\n                         },\\n                         validationMessage: {\\n                           get: mark(function () {\\n                             return validationMessage(this);\\n                           })\\n                         },\\n                         validity: {\\n                           get: mark(function () {\\n                             return ValidityState(this);\\n                           })\\n                         },\\n                         valueAsDate: {\\n                           get: mark(function () {\\n                             return valueAsDate(this);\\n                           }),\\n                           set: mark(function (value) {\\n                             valueAsDate(this, value);\\n                           })\\n                         },\\n                         valueAsNumber: {\\n                           get: mark(function () {\\n                             return valueAsNumber(this);\\n                           }),\\n                           set: mark(function (value) {\\n                             valueAsNumber(this, value);\\n                           })\\n                         },\\n                         willValidate: {\\n                           get: mark(function () {\\n                             return willValidate(this);\\n                           })\\n                         }\\n                       };\\n\\n                       function polyfill (element) {\\n                         if (is_field(element)) {\\n\\n                           for (var prop in polyfills) {\\n                             install_property(element, prop, polyfills[prop]);\\n                           }\\n\\n                           install_properties(element);\\n                         } else if (element instanceof window.HTMLFormElement || element === window.HTMLFormElement.prototype) {\\n                           install_property(element, 'checkValidity', polyfills.checkValidity);\\n                           install_property(element, 'reportValidity', polyfills.reportValidity);\\n                         }\\n                       }\\n\\n                       function polyunfill (element) {\\n                         if (is_field(element)) {\\n\\n                           uninstall_property(element, 'checkValidity');\\n                           uninstall_property(element, 'reportValidity');\\n                           uninstall_property(element, 'setCustomValidity');\\n                           uninstall_property(element, 'stepDown');\\n                           uninstall_property(element, 'stepUp');\\n                           uninstall_property(element, 'validationMessage');\\n                           uninstall_property(element, 'validity');\\n                           uninstall_property(element, 'valueAsDate');\\n                           uninstall_property(element, 'valueAsNumber');\\n                           uninstall_property(element, 'willValidate');\\n\\n                           uninstall_properties(element);\\n                         } else if (element instanceof window.HTMLFormElement) {\\n                           uninstall_property(element, 'checkValidity');\\n                           uninstall_property(element, 'reportValidity');\\n                         }\\n                       }\\n\\n                       var instances = new WeakMap();\\n\\n                       /**\\n                        * wrap <form>s, window or document, that get treated with the global\\n                        * hyperform()\\n                        */\\n                       function Wrapper(form, settings) {\\n\\n                         /* do not allow more than one instance per form. Otherwise we'd end\\n                          * up with double event handlers, polyfills re-applied, ... */\\n                         var existing = instances.get(form);\\n                         if (existing) {\\n                           existing.settings = settings;\\n                           return existing;\\n                         }\\n\\n                         this.form = form;\\n                         this.settings = settings;\\n                         this.revalidator = this.revalidate.bind(this);\\n\\n                         instances.set(form, this);\\n\\n                         catch_submit(form, settings.revalidate === 'never');\\n\\n                         if (form === window || form.nodeType === 9) {\\n                           /* install on the prototypes, when called for the whole document */\\n                           this.install([window.HTMLButtonElement.prototype, window.HTMLInputElement.prototype, window.HTMLSelectElement.prototype, window.HTMLTextAreaElement.prototype, window.HTMLFieldSetElement.prototype]);\\n                           polyfill(window.HTMLFormElement);\\n                         } else if (form instanceof window.HTMLFormElement || form instanceof window.HTMLFieldSetElement) {\\n                           this.install(form.elements);\\n                           if (form instanceof window.HTMLFormElement) {\\n                             polyfill(form);\\n                           }\\n                         }\\n\\n                         if (settings.revalidate === 'oninput' || settings.revalidate === 'hybrid') {\\n                           /* in a perfect world we'd just bind to \\\"input\\\", but support here is\\n                            * abysmal: http://caniuse.com/#feat=input-event */\\n                           form.addEventListener('keyup', this.revalidator);\\n                           form.addEventListener('change', this.revalidator);\\n                         }\\n                         if (settings.revalidate === 'onblur' || settings.revalidate === 'hybrid') {\\n                           /* useCapture=true, because `blur` doesn't bubble. See\\n                            * https://developer.mozilla.org/en-US/docs/Web/Events/blur#Event_delegation\\n                            * for a discussion */\\n                           form.addEventListener('blur', this.revalidator, true);\\n                         }\\n                       }\\n\\n                       Wrapper.prototype = {\\n                         destroy: function destroy() {\\n                           uncatch_submit(this.form);\\n                           instances.delete(this.form);\\n                           this.form.removeEventListener('keyup', this.revalidator);\\n                           this.form.removeEventListener('change', this.revalidator);\\n                           this.form.removeEventListener('blur', this.revalidator, true);\\n                           if (this.form === window || this.form.nodeType === 9) {\\n                             this.uninstall([window.HTMLButtonElement.prototype, window.HTMLInputElement.prototype, window.HTMLSelectElement.prototype, window.HTMLTextAreaElement.prototype, window.HTMLFieldSetElement.prototype]);\\n                             polyunfill(window.HTMLFormElement);\\n                           } else if (this.form instanceof window.HTMLFormElement || this.form instanceof window.HTMLFieldSetElement) {\\n                             this.uninstall(this.form.elements);\\n                             if (this.form instanceof window.HTMLFormElement) {\\n                               polyunfill(this.form);\\n                             }\\n                           }\\n                         },\\n\\n\\n                         /**\\n                          * revalidate an input element\\n                          */\\n                         revalidate: function revalidate(event) {\\n                           if (event.target instanceof window.HTMLButtonElement || event.target instanceof window.HTMLTextAreaElement || event.target instanceof window.HTMLSelectElement || event.target instanceof window.HTMLInputElement) {\\n\\n                             if (this.settings.revalidate === 'hybrid') {\\n                               /* \\\"hybrid\\\" somewhat simulates what browsers do. See for example\\n                                * Firefox's :-moz-ui-invalid pseudo-class:\\n                                * https://developer.mozilla.org/en-US/docs/Web/CSS/:-moz-ui-invalid */\\n                               if (event.type === 'blur' && event.target.value !== event.target.defaultValue || ValidityState(event.target).valid) {\\n                                 /* on blur, update the report when the value has changed from the\\n                                  * default or when the element is valid (possibly removing a still\\n                                  * standing invalidity report). */\\n                                 reportValidity(event.target);\\n                               } else if (event.type === 'keyup' || event.type === 'change') {\\n                                 if (ValidityState(event.target).valid) {\\n                                   // report instantly, when an element becomes valid,\\n                                   // postpone report to blur event, when an element is invalid\\n                                   reportValidity(event.target);\\n                                 }\\n                               }\\n                             } else {\\n                               reportValidity(event.target);\\n                             }\\n                           }\\n                         },\\n\\n\\n                         /**\\n                          * install the polyfills on each given element\\n                          *\\n                          * If you add elements dynamically, you have to call install() on them\\n                          * yourself:\\n                          *\\n                          * js> var form = hyperform(document.forms[0]);\\n                          * js> document.forms[0].appendChild(input);\\n                          * js> form.install(input);\\n                          *\\n                          * You can skip this, if you called hyperform on window or document.\\n                          */\\n                         install: function install(els) {\\n                           if (els instanceof window.Element) {\\n                             els = [els];\\n                           }\\n\\n                           var els_length = els.length;\\n\\n                           for (var i = 0; i < els_length; i++) {\\n                             polyfill(els[i]);\\n                           }\\n                         },\\n                         uninstall: function uninstall(els) {\\n                           if (els instanceof window.Element) {\\n                             els = [els];\\n                           }\\n\\n                           var els_length = els.length;\\n\\n                           for (var i = 0; i < els_length; i++) {\\n                             polyunfill(els[i]);\\n                           }\\n                         }\\n                       };\\n\\n                       /**\\n                        * try to get the appropriate wrapper for a specific element by looking up\\n                        * its parent chain\\n                        *\\n                        * @return Wrapper | undefined\\n                        */\\n                       function get_wrapper(element) {\\n                         var wrapped;\\n\\n                         if (element.form) {\\n                           /* try a shortcut with the element's <form> */\\n                           wrapped = instances.get(element.form);\\n                         }\\n\\n                         /* walk up the parent nodes until document (including) */\\n                         while (!wrapped && element) {\\n                           wrapped = instances.get(element);\\n                           element = element.parentNode;\\n                         }\\n\\n                         if (!wrapped) {\\n                           /* try the global instance, if exists. This may also be undefined. */\\n                           wrapped = instances.get(window);\\n                         }\\n\\n                         return wrapped;\\n                       }\\n\\n                       /**\\n                        * check if an element is a candidate for constraint validation\\n                        *\\n                        * @see https://html.spec.whatwg.org/multipage/forms.html#barred-from-constraint-validation\\n                        */\\n                       function is_validation_candidate (element) {\\n\\n                         /* allow a shortcut via filters, e.g. to validate type=hidden fields */\\n                         var filtered = do_filter('is_validation_candidate', null, element);\\n                         if (filtered !== null) {\\n                           return !!filtered;\\n                         }\\n\\n                         /* it must be any of those elements */\\n                         if (element instanceof window.HTMLSelectElement || element instanceof window.HTMLTextAreaElement || element instanceof window.HTMLButtonElement || element instanceof window.HTMLInputElement) {\\n\\n                           var type = get_type(element);\\n                           /* its type must be in the whitelist or missing (select, textarea) */\\n                           if (!type || non_inputs.indexOf(type) > -1 || validation_candidates.indexOf(type) > -1) {\\n\\n                             /* it mustn't be disabled or readonly */\\n                             if (!element.hasAttribute('disabled') && !element.hasAttribute('readonly')) {\\n\\n                               var wrapped_form = get_wrapper(element);\\n                               /* it hasn't got the (non-standard) attribute 'novalidate' or its\\n                                * parent form has got the strict parameter */\\n                               if (wrapped_form && wrapped_form.settings.novalidateOnElements || !element.hasAttribute('novalidate') || !element.noValidate) {\\n\\n                                 /* it isn't part of a <fieldset disabled> */\\n                                 var p = element.parentNode;\\n                                 while (p && p.nodeType === 1) {\\n                                   if (p instanceof window.HTMLFieldSetElement && p.hasAttribute('disabled')) {\\n                                     /* quick return, if it's a child of a disabled fieldset */\\n                                     return false;\\n                                   } else if (p.nodeName.toUpperCase() === 'DATALIST') {\\n                                     /* quick return, if it's a child of a datalist\\n                                      * Do not use HTMLDataListElement to support older browsers,\\n                                      * too.\\n                                      * @see https://html.spec.whatwg.org/multipage/forms.html#the-datalist-element:barred-from-constraint-validation\\n                                      */\\n                                     return false;\\n                                   } else if (p === element.form) {\\n                                     /* the outer boundary. We can stop looking for relevant\\n                                      * fieldsets. */\\n                                     break;\\n                                   }\\n                                   p = p.parentNode;\\n                                 }\\n\\n                                 /* then it's a candidate */\\n                                 return true;\\n                               }\\n                             }\\n                           }\\n                         }\\n\\n                         /* this is no HTML5 validation candidate... */\\n                         return false;\\n                       }\\n\\n                       function format_date (date) {\\n                         var part = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\\n\\n                         switch (part) {\\n                           case 'date':\\n                             return (date.toLocaleDateString || date.toDateString).call(date);\\n                           case 'time':\\n                             return (date.toLocaleTimeString || date.toTimeString).call(date);\\n                           case 'month':\\n                             return 'toLocaleDateString' in date ? date.toLocaleDateString(undefined, {\\n                               year: 'numeric',\\n                               month: '2-digit'\\n                             }) : date.toDateString();\\n                           // case 'week':\\n                           // TODO\\n                           default:\\n                             return (date.toLocaleString || date.toString).call(date);\\n                         }\\n                       }\\n\\n                       /**\\n                        * patch String.length to account for non-BMP characters\\n                        *\\n                        * @see https://mathiasbynens.be/notes/javascript-unicode\\n                        * We do not use the simple [...str].length, because it needs a ton of\\n                        * polyfills in older browsers.\\n                        */\\n\\n                       function unicode_string_length (str) {\\n                         return str.match(/[\\\\0-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF]/g).length;\\n                       }\\n\\n                       /**\\n                        * internal storage for custom error messages\\n                        */\\n\\n                       var store$1 = new WeakMap();\\n\\n                       /**\\n                        * register custom error messages per element\\n                        */\\n                       var custom_messages = {\\n                         set: function set(element, validator, message) {\\n                           var messages = store$1.get(element) || {};\\n                           messages[validator] = message;\\n                           store$1.set(element, messages);\\n                           return custom_messages;\\n                         },\\n                         get: function get(element, validator) {\\n                           var _default = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\\n\\n                           var messages = store$1.get(element);\\n                           if (messages === undefined || !(validator in messages)) {\\n                             var data_id = 'data-' + validator.replace(/[A-Z]/g, '-$&').toLowerCase();\\n                             if (element.hasAttribute(data_id)) {\\n                               /* if the element has a data-validator attribute, use this as fallback.\\n                                * E.g., if validator == 'valueMissing', the element can specify a\\n                                * custom validation message like this:\\n                                *     <input data-value-missing=\\\"Oh noes!\\\">\\n                                */\\n                               return element.getAttribute(data_id);\\n                             }\\n                             return _default;\\n                           }\\n                           return messages[validator];\\n                         },\\n                         delete: function _delete(element) {\\n                           var validator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\\n\\n                           if (!validator) {\\n                             return store$1.delete(element);\\n                           }\\n                           var messages = store$1.get(element) || {};\\n                           if (validator in messages) {\\n                             delete messages[validator];\\n                             store$1.set(element, messages);\\n                             return true;\\n                           }\\n                           return false;\\n                         }\\n                       };\\n\\n                       var internal_registry = new WeakMap();\\n\\n                       /**\\n                        * A registry for custom validators\\n                        *\\n                        * slim wrapper around a WeakMap to ensure the values are arrays\\n                        * (hence allowing > 1 validators per element)\\n                        */\\n                       var custom_validator_registry = {\\n                         set: function set(element, validator) {\\n                           var current = internal_registry.get(element) || [];\\n                           current.push(validator);\\n                           internal_registry.set(element, current);\\n                           return custom_validator_registry;\\n                         },\\n                         get: function get(element) {\\n                           return internal_registry.get(element) || [];\\n                         },\\n                         delete: function _delete(element) {\\n                           return internal_registry.delete(element);\\n                         }\\n                       };\\n\\n                       /**\\n                        * test whether the element suffers from bad input\\n                        */\\n                       function test_bad_input (element) {\\n                         var type = get_type(element);\\n\\n                         if (!is_validation_candidate(element) || input_checked.indexOf(type) === -1) {\\n                           /* we're not interested, thanks! */\\n                           return true;\\n                         }\\n\\n                         /* the browser hides some bad input from the DOM, e.g. malformed numbers,\\n                          * email addresses with invalid punycode representation, ... We try to resort\\n                          * to the original method here. The assumption is, that a browser hiding\\n                          * bad input will hopefully also always support a proper\\n                          * ValidityState.badInput */\\n                         if (!element.value) {\\n                           if ('_original_validity' in element && !element._original_validity.__hyperform) {\\n                             return !element._original_validity.badInput;\\n                           }\\n                           /* no value and no original badInput: Assume all's right. */\\n                           return true;\\n                         }\\n\\n                         var result = true;\\n                         switch (type) {\\n                           case 'color':\\n                             result = /^#[a-f0-9]{6}$/.test(element.value);\\n                             break;\\n                           case 'number':\\n                           case 'range':\\n                             result = !isNaN(Number(element.value));\\n                             break;\\n                           case 'datetime':\\n                           case 'date':\\n                           case 'month':\\n                           case 'week':\\n                           case 'time':\\n                             result = string_to_date(element.value, type) !== null;\\n                             break;\\n                           case 'datetime-local':\\n                             result = /^([0-9]{4,})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9])(?:\\\\.([0-9]{1,3}))?)?$/.test(element.value);\\n                             break;\\n                           case 'tel':\\n                             /* spec says No! Phone numbers can have all kinds of formats, so this\\n                              * is expected to be a free-text field. */\\n                             // TODO we could allow a setting 'phone_regex' to be evaluated here.\\n                             break;\\n                           case 'email':\\n                             break;\\n                         }\\n\\n                         return result;\\n                       }\\n\\n                       /**\\n                        * test the max attribute\\n                        *\\n                        * we use Number() instead of parseFloat(), because an invalid attribute\\n                        * value like \\\"123abc\\\" should result in an error.\\n                        */\\n                       function test_max (element) {\\n                         var type = get_type(element);\\n\\n                         if (!is_validation_candidate(element) || !element.value || !element.hasAttribute('max')) {\\n                           /* we're not responsible here */\\n                           return true;\\n                         }\\n\\n                         var value = void 0,\\n                             max = void 0;\\n                         if (dates.indexOf(type) > -1) {\\n                           value = 1 * string_to_date(element.value, type);\\n                           max = 1 * (string_to_date(element.getAttribute('max'), type) || NaN);\\n                         } else {\\n                           value = Number(element.value);\\n                           max = Number(element.getAttribute('max'));\\n                         }\\n\\n                         return isNaN(max) || value <= max;\\n                       }\\n\\n                       /**\\n                        * test the maxlength attribute\\n                        */\\n                       function test_maxlength (element) {\\n                         if (!is_validation_candidate(element) || !element.value || text_types.indexOf(get_type(element)) === -1 || !element.hasAttribute('maxlength') || !element.getAttribute('maxlength') // catch maxlength=\\\"\\\"\\n                         ) {\\n                             return true;\\n                           }\\n\\n                         var maxlength = parseInt(element.getAttribute('maxlength'), 10);\\n\\n                         /* check, if the maxlength value is usable at all.\\n                          * We allow maxlength === 0 to basically disable input (Firefox does, too).\\n                          */\\n                         if (isNaN(maxlength) || maxlength < 0) {\\n                           return true;\\n                         }\\n\\n                         return unicode_string_length(element.value) <= maxlength;\\n                       }\\n\\n                       /**\\n                        * test the min attribute\\n                        *\\n                        * we use Number() instead of parseFloat(), because an invalid attribute\\n                        * value like \\\"123abc\\\" should result in an error.\\n                        */\\n                       function test_min (element) {\\n                         var type = get_type(element);\\n\\n                         if (!is_validation_candidate(element) || !element.value || !element.hasAttribute('min')) {\\n                           /* we're not responsible here */\\n                           return true;\\n                         }\\n\\n                         var value = void 0,\\n                             min = void 0;\\n                         if (dates.indexOf(type) > -1) {\\n                           value = 1 * string_to_date(element.value, type);\\n                           min = 1 * (string_to_date(element.getAttribute('min'), type) || NaN);\\n                         } else {\\n                           value = Number(element.value);\\n                           min = Number(element.getAttribute('min'));\\n                         }\\n\\n                         return isNaN(min) || value >= min;\\n                       }\\n\\n                       /**\\n                        * test the minlength attribute\\n                        */\\n                       function test_minlength (element) {\\n                         if (!is_validation_candidate(element) || !element.value || text_types.indexOf(get_type(element)) === -1 || !element.hasAttribute('minlength') || !element.getAttribute('minlength') // catch minlength=\\\"\\\"\\n                         ) {\\n                             return true;\\n                           }\\n\\n                         var minlength = parseInt(element.getAttribute('minlength'), 10);\\n\\n                         /* check, if the minlength value is usable at all. */\\n                         if (isNaN(minlength) || minlength < 0) {\\n                           return true;\\n                         }\\n\\n                         return unicode_string_length(element.value) >= minlength;\\n                       }\\n\\n                       /**\\n                        * test the pattern attribute\\n                        */\\n                       function test_pattern (element) {\\n                           return !is_validation_candidate(element) || !element.value || !element.hasAttribute('pattern') || new RegExp('^(?:' + element.getAttribute('pattern') + ')$').test(element.value);\\n                       }\\n\\n                       /**\\n                        * test the required attribute\\n                        */\\n                       function test_required (element) {\\n                         if (!is_validation_candidate(element) || !element.hasAttribute('required')) {\\n                           /* nothing to do */\\n                           return true;\\n                         }\\n\\n                         /* we don't need get_type() for element.type, because \\\"checkbox\\\" and \\\"radio\\\"\\n                          * are well supported. */\\n                         switch (element.type) {\\n                           case 'checkbox':\\n                             return element.checked;\\n                           //break;\\n                           case 'radio':\\n                             /* radio inputs have \\\"required\\\" fulfilled, if _any_ other radio\\n                              * with the same name in this form is checked. */\\n                             return !!(element.checked || element.form && Array.prototype.filter.call(document.getElementsByName(element.name), function (radio) {\\n                               return radio.name === element.name && radio.form === element.form && radio.checked;\\n                             }).length > 0);\\n                           //break;\\n                           default:\\n                             return !!element.value;\\n                         }\\n                       }\\n\\n                       /**\\n                        * test the step attribute\\n                        */\\n                       function test_step (element) {\\n                         var type = get_type(element);\\n\\n                         if (!is_validation_candidate(element) || !element.value || numbers.indexOf(type) === -1 || (element.getAttribute('step') || '').toLowerCase() === 'any') {\\n                           /* we're not responsible here. Note: If no step attribute is given, we\\n                            * need to validate against the default step as per spec. */\\n                           return true;\\n                         }\\n\\n                         var step = element.getAttribute('step');\\n                         if (step) {\\n                           step = string_to_number(step, type);\\n                         } else {\\n                           step = default_step[type] || 1;\\n                         }\\n\\n                         if (step <= 0 || isNaN(step)) {\\n                           /* error in specified \\\"step\\\". We cannot validate against it, so the value\\n                            * is true. */\\n                           return true;\\n                         }\\n\\n                         var scale = step_scale_factor[type] || 1;\\n\\n                         var value = string_to_number(element.value, type);\\n                         var min = string_to_number(element.getAttribute('min') || element.getAttribute('value') || '', type);\\n\\n                         if (isNaN(min)) {\\n                           min = default_step_base[type] || 0;\\n                         }\\n\\n                         if (type === 'month') {\\n                           /* type=month has month-wide steps. See\\n                            * https://html.spec.whatwg.org/multipage/forms.html#month-state-%28type=month%29\\n                            */\\n                           min = new Date(min).getUTCFullYear() * 12 + new Date(min).getUTCMonth();\\n                           value = new Date(value).getUTCFullYear() * 12 + new Date(value).getUTCMonth();\\n                         }\\n\\n                         var result = Math.abs(min - value) % (step * scale);\\n\\n                         return result < 0.00000001 ||\\n                         /* crappy floating-point arithmetics! */\\n                         result > step * scale - 0.00000001;\\n                       }\\n\\n                       var ws_on_start_or_end = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g;\\n\\n                       /**\\n                        * trim a string of whitespace\\n                        *\\n                        * We don't use String.trim() to remove the need to polyfill it.\\n                        */\\n                       function trim (str) {\\n                         return str.replace(ws_on_start_or_end, '');\\n                       }\\n\\n                       /**\\n                        * split a string on comma and trim the components\\n                        *\\n                        * As specified at\\n                        * https://html.spec.whatwg.org/multipage/infrastructure.html#split-a-string-on-commas\\n                        * plus removing empty entries.\\n                        */\\n                       function comma_split (str) {\\n                         return str.split(',').map(function (item) {\\n                           return trim(item);\\n                         }).filter(function (b) {\\n                           return b;\\n                         });\\n                       }\\n\\n                       /* we use a dummy <a> where we set the href to test URL validity\\n                        * The definition is out of the \\\"global\\\" scope so that JSDOM can be instantiated\\n                        * after loading Hyperform for tests.\\n                        */\\n                       var url_canary;\\n\\n                       /* see https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address */\\n                       var email_pattern = /^[a-zA-Z0-9.!#$%&'*+\\\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\\n\\n                       /**\\n                        * test the type-inherent syntax\\n                        */\\n                       function test_type (element) {\\n                         var type = get_type(element);\\n\\n                         if (!is_validation_candidate(element) || type !== 'file' && !element.value || type !== 'file' && type_checked.indexOf(type) === -1) {\\n                           /* we're not responsible for this element */\\n                           return true;\\n                         }\\n\\n                         var is_valid = true;\\n\\n                         switch (type) {\\n                           case 'url':\\n                             if (!url_canary) {\\n                               url_canary = document.createElement('a');\\n                             }\\n                             var value = trim(element.value);\\n                             url_canary.href = value;\\n                             is_valid = url_canary.href === value || url_canary.href === value + '/';\\n                             break;\\n                           case 'email':\\n                             if (element.hasAttribute('multiple')) {\\n                               is_valid = comma_split(element.value).every(function (value) {\\n                                 return email_pattern.test(value);\\n                               });\\n                             } else {\\n                               is_valid = email_pattern.test(trim(element.value));\\n                             }\\n                             break;\\n                           case 'file':\\n                             if ('files' in element && element.files.length && element.hasAttribute('accept')) {\\n                               var patterns = comma_split(element.getAttribute('accept')).map(function (pattern) {\\n                                 if (/^(audio|video|image)\\\\/\\\\*$/.test(pattern)) {\\n                                   pattern = new RegExp('^' + RegExp.$1 + '/.+$');\\n                                 }\\n                                 return pattern;\\n                               });\\n\\n                               if (!patterns.length) {\\n                                 break;\\n                               }\\n\\n                               fileloop: for (var i = 0; i < element.files.length; i++) {\\n                                 /* we need to match a whitelist, so pre-set with false */\\n                                 var file_valid = false;\\n\\n                                 patternloop: for (var j = 0; j < patterns.length; j++) {\\n                                   var file = element.files[i];\\n                                   var pattern = patterns[j];\\n\\n                                   var fileprop = file.type;\\n\\n                                   if (typeof pattern === 'string' && pattern.substr(0, 1) === '.') {\\n                                     if (file.name.search('.') === -1) {\\n                                       /* no match with any file ending */\\n                                       continue patternloop;\\n                                     }\\n\\n                                     fileprop = file.name.substr(file.name.lastIndexOf('.'));\\n                                   }\\n\\n                                   if (fileprop.search(pattern) === 0) {\\n                                     /* we found one match and can quit looking */\\n                                     file_valid = true;\\n                                     break patternloop;\\n                                   }\\n                                 }\\n\\n                                 if (!file_valid) {\\n                                   is_valid = false;\\n                                   break fileloop;\\n                                 }\\n                               }\\n                             }\\n                         }\\n\\n                         return is_valid;\\n                       }\\n\\n                       /**\\n                        * boilerplate function for all tests but customError\\n                        */\\n                       function check$1(test, react) {\\n                         return function (element) {\\n                           var invalid = !test(element);\\n                           if (invalid) {\\n                             react(element);\\n                           }\\n                           return invalid;\\n                         };\\n                       }\\n\\n                       /**\\n                        * create a common function to set error messages\\n                        */\\n                       function set_msg(element, msgtype, _default) {\\n                         message_store.set(element, custom_messages.get(element, msgtype, _default));\\n                       }\\n\\n                       var badInput = check$1(test_bad_input, function (element) {\\n                         return set_msg(element, 'badInput', _('Please match the requested type.'));\\n                       });\\n\\n                       function customError(element) {\\n                         /* check, if there are custom validators in the registry, and call\\n                          * them. */\\n                         var custom_validators = custom_validator_registry.get(element);\\n                         var cvl = custom_validators.length;\\n                         var valid = true;\\n\\n                         if (cvl) {\\n                           for (var i = 0; i < cvl; i++) {\\n                             var result = custom_validators[i](element);\\n                             if (result !== undefined && !result) {\\n                               valid = false;\\n                               /* break on first invalid response */\\n                               break;\\n                             }\\n                           }\\n                         }\\n\\n                         /* check, if there are other validity messages already */\\n                         if (valid) {\\n                           var msg = message_store.get(element);\\n                           valid = !(msg.toString() && 'is_custom' in msg);\\n                         }\\n\\n                         return !valid;\\n                       }\\n\\n                       var patternMismatch = check$1(test_pattern, function (element) {\\n                         set_msg(element, 'patternMismatch', element.title ? sprintf(_('PatternMismatchWithTitle'), element.title) : _('PatternMismatch'));\\n                       });\\n\\n                       /**\\n                        * TODO: when rangeOverflow and rangeUnderflow are both called directly and\\n                        * successful, the inRange and outOfRange classes won't get removed, unless\\n                        * element.validityState.valid is queried, too.\\n                        */\\n                       var rangeOverflow = check$1(test_max, function (element) {\\n                         var type = get_type(element);\\n                         var wrapper = get_wrapper(element);\\n                         var outOfRangeClass = wrapper && wrapper.settings.classes.outOfRange || 'hf-out-of-range';\\n                         var inRangeClass = wrapper && wrapper.settings.classes.inRange || 'hf-in-range';\\n\\n                         var msg = void 0;\\n\\n                         switch (type) {\\n                           case 'date':\\n                           case 'datetime':\\n                           case 'datetime-local':\\n                             msg = sprintf(_('DateRangeOverflow'), format_date(string_to_date(element.getAttribute('max'), type), type));\\n                             break;\\n                           case 'time':\\n                             msg = sprintf(_('TimeRangeOverflow'), format_date(string_to_date(element.getAttribute('max'), type), type));\\n                             break;\\n                           // case 'number':\\n                           default:\\n                             msg = sprintf(_('NumberRangeOverflow'), string_to_number(element.getAttribute('max'), type));\\n                             break;\\n                         }\\n\\n                         set_msg(element, 'rangeOverflow', msg);\\n                         element.classList.add(outOfRangeClass);\\n                         element.classList.remove(inRangeClass);\\n                       });\\n\\n                       var rangeUnderflow = check$1(test_min, function (element) {\\n                         var type = get_type(element);\\n                         var wrapper = get_wrapper(element);\\n                         var outOfRangeClass = wrapper && wrapper.settings.classes.outOfRange || 'hf-out-of-range';\\n                         var inRangeClass = wrapper && wrapper.settings.classes.inRange || 'hf-in-range';\\n\\n                         var msg = void 0;\\n\\n                         switch (type) {\\n                           case 'date':\\n                           case 'datetime':\\n                           case 'datetime-local':\\n                             msg = sprintf(_('DateRangeUnderflow'), format_date(string_to_date(element.getAttribute('min'), type), type));\\n                             break;\\n                           case 'time':\\n                             msg = sprintf(_('TimeRangeUnderflow'), format_date(string_to_date(element.getAttribute('min'), type), type));\\n                             break;\\n                           // case 'number':\\n                           default:\\n                             msg = sprintf(_('NumberRangeUnderflow'), string_to_number(element.getAttribute('min'), type));\\n                             break;\\n                         }\\n\\n                         set_msg(element, 'rangeUnderflow', msg);\\n                         element.classList.add(outOfRangeClass);\\n                         element.classList.remove(inRangeClass);\\n                       });\\n\\n                       var stepMismatch = check$1(test_step, function (element) {\\n                         var list = get_next_valid(element);\\n                         var min = list[0];\\n                         var max = list[1];\\n                         var sole = false;\\n                         var msg = void 0;\\n\\n                         if (min === null) {\\n                           sole = max;\\n                         } else if (max === null) {\\n                           sole = min;\\n                         }\\n\\n                         if (sole !== false) {\\n                           msg = sprintf(_('StepMismatchOneValue'), sole);\\n                         } else {\\n                           msg = sprintf(_('StepMismatch'), min, max);\\n                         }\\n                         set_msg(element, 'stepMismatch', msg);\\n                       });\\n\\n                       var tooLong = check$1(test_maxlength, function (element) {\\n                         set_msg(element, 'tooLong', sprintf(_('TextTooLong'), element.getAttribute('maxlength'), unicode_string_length(element.value)));\\n                       });\\n\\n                       var tooShort = check$1(test_minlength, function (element) {\\n                         set_msg(element, 'tooShort', sprintf(_('Please lengthen this text to %l characters or more (you are currently using %l characters).'), element.getAttribute('minlength'), unicode_string_length(element.value)));\\n                       });\\n\\n                       var typeMismatch = check$1(test_type, function (element) {\\n                         var msg = _('Please use the appropriate format.');\\n                         var type = get_type(element);\\n\\n                         if (type === 'email') {\\n                           if (element.hasAttribute('multiple')) {\\n                             msg = _('Please enter a comma separated list of email addresses.');\\n                           } else {\\n                             msg = _('InvalidEmail');\\n                           }\\n                         } else if (type === 'url') {\\n                           msg = _('InvalidURL');\\n                         } else if (type === 'file') {\\n                           msg = _('Please select a file of the correct type.');\\n                         }\\n\\n                         set_msg(element, 'typeMismatch', msg);\\n                       });\\n\\n                       var valueMissing = check$1(test_required, function (element) {\\n                         var msg = _('ValueMissing');\\n                         var type = get_type(element);\\n\\n                         if (type === 'checkbox') {\\n                           msg = _('CheckboxMissing');\\n                         } else if (type === 'radio') {\\n                           msg = _('RadioMissing');\\n                         } else if (type === 'file') {\\n                           if (element.hasAttribute('multiple')) {\\n                             msg = _('Please select one or more files.');\\n                           } else {\\n                             msg = _('FileMissing');\\n                           }\\n                         } else if (element instanceof window.HTMLSelectElement) {\\n                           msg = _('SelectMissing');\\n                         }\\n\\n                         set_msg(element, 'valueMissing', msg);\\n                       });\\n\\n                       var validity_state_checkers = {\\n                         badInput: badInput,\\n                         customError: customError,\\n                         patternMismatch: patternMismatch,\\n                         rangeOverflow: rangeOverflow,\\n                         rangeUnderflow: rangeUnderflow,\\n                         stepMismatch: stepMismatch,\\n                         tooLong: tooLong,\\n                         tooShort: tooShort,\\n                         typeMismatch: typeMismatch,\\n                         valueMissing: valueMissing\\n                       };\\n\\n                       /**\\n                        * the validity state constructor\\n                        */\\n                       var ValidityState = function ValidityState(element) {\\n                         if (!(element instanceof window.HTMLElement)) {\\n                           throw new Error('cannot create a ValidityState for a non-element');\\n                         }\\n\\n                         var cached = ValidityState.cache.get(element);\\n                         if (cached) {\\n                           return cached;\\n                         }\\n\\n                         if (!(this instanceof ValidityState)) {\\n                           /* working around a forgotten `new` */\\n                           return new ValidityState(element);\\n                         }\\n\\n                         this.element = element;\\n                         ValidityState.cache.set(element, this);\\n                       };\\n\\n                       /**\\n                        * the prototype for new validityState instances\\n                        */\\n                       var ValidityStatePrototype = {};\\n                       ValidityState.prototype = ValidityStatePrototype;\\n\\n                       ValidityState.cache = new WeakMap();\\n\\n                       /**\\n                        * copy functionality from the validity checkers to the ValidityState\\n                        * prototype\\n                        */\\n                       for (var prop in validity_state_checkers) {\\n                         Object.defineProperty(ValidityStatePrototype, prop, {\\n                           configurable: true,\\n                           enumerable: true,\\n                           get: function (func) {\\n                             return function () {\\n                               return func(this.element);\\n                             };\\n                           }(validity_state_checkers[prop]),\\n                           set: undefined\\n                         });\\n                       }\\n\\n                       /**\\n                        * the \\\"valid\\\" property calls all other validity checkers and returns true,\\n                        * if all those return false.\\n                        *\\n                        * This is the major access point for _all_ other API methods, namely\\n                        * (check|report)Validity().\\n                        */\\n                       Object.defineProperty(ValidityStatePrototype, 'valid', {\\n                         configurable: true,\\n                         enumerable: true,\\n                         get: function get() {\\n                           var wrapper = get_wrapper(this.element);\\n                           var validClass = wrapper && wrapper.settings.classes.valid || 'hf-valid';\\n                           var invalidClass = wrapper && wrapper.settings.classes.invalid || 'hf-invalid';\\n                           var userInvalidClass = wrapper && wrapper.settings.classes.userInvalid || 'hf-user-invalid';\\n                           var userValidClass = wrapper && wrapper.settings.classes.userValid || 'hf-user-valid';\\n                           var inRangeClass = wrapper && wrapper.settings.classes.inRange || 'hf-in-range';\\n                           var outOfRangeClass = wrapper && wrapper.settings.classes.outOfRange || 'hf-out-of-range';\\n                           var validatedClass = wrapper && wrapper.settings.classes.validated || 'hf-validated';\\n\\n                           this.element.classList.add(validatedClass);\\n\\n                           if (is_validation_candidate(this.element)) {\\n                             for (var _prop in validity_state_checkers) {\\n                               if (validity_state_checkers[_prop](this.element)) {\\n                                 this.element.classList.add(invalidClass);\\n                                 this.element.classList.remove(validClass);\\n                                 this.element.classList.remove(userValidClass);\\n                                 if (this.element.value !== this.element.defaultValue) {\\n                                   this.element.classList.add(userInvalidClass);\\n                                 } else {\\n                                   this.element.classList.remove(userInvalidClass);\\n                                 }\\n                                 this.element.setAttribute('aria-invalid', 'true');\\n                                 return false;\\n                               }\\n                             }\\n                           }\\n\\n                           message_store.delete(this.element);\\n                           this.element.classList.remove(invalidClass, userInvalidClass, outOfRangeClass);\\n                           this.element.classList.add(validClass, inRangeClass);\\n                           if (this.element.value !== this.element.defaultValue) {\\n                             this.element.classList.add(userValidClass);\\n                           } else {\\n                             this.element.classList.remove(userValidClass);\\n                           }\\n                           this.element.setAttribute('aria-invalid', 'false');\\n                           return true;\\n                         },\\n                         set: undefined\\n                       });\\n\\n                       /**\\n                        * mark the validity prototype, because that is what the client-facing\\n                        * code deals with mostly, not the property descriptor thing */\\n                       mark(ValidityStatePrototype);\\n\\n                       /**\\n                        * check an element's validity with respect to it's form\\n                        */\\n                       var checkValidity = return_hook_or('checkValidity', function (element) {\\n                         /* if this is a <form>, check validity of all child inputs */\\n                         if (element instanceof window.HTMLFormElement) {\\n                           return Array.prototype.map.call(element.elements, checkValidity).every(function (b) {\\n                             return b;\\n                           });\\n                         }\\n\\n                         /* default is true, also for elements that are no validation candidates */\\n                         var valid = ValidityState(element).valid;\\n                         if (valid) {\\n                           var wrapped_form = get_wrapper(element);\\n                           if (wrapped_form && wrapped_form.settings.validEvent) {\\n                             trigger_event(element, 'valid');\\n                           }\\n                         } else {\\n                           trigger_event(element, 'invalid', { cancelable: true });\\n                         }\\n\\n                         return valid;\\n                       });\\n\\n                       var version = '0.9.5';\\n\\n                       /* deprecate the old snake_case names\\n                        * TODO: delme before next non-patch release\\n                        */\\n                       function w(name) {\\n                         var deprecated_message = 'Please use camelCase method names! The name \\\"%s\\\" is deprecated and will be removed in the next non-patch release.';\\n                         /* global console */\\n                         console.log(sprintf(deprecated_message, name));\\n                       }\\n\\n                       /**\\n                        * public hyperform interface:\\n                        */\\n                       function hyperform(form) {\\n                         var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n                         var classes = _ref.classes;\\n                         var _ref$debug = _ref.debug;\\n                         var debug = _ref$debug === undefined ? false : _ref$debug;\\n                         var extend_fieldset = _ref.extend_fieldset;\\n                         var extendFieldset = _ref.extendFieldset;\\n                         var novalidate_on_elements = _ref.novalidate_on_elements;\\n                         var novalidateOnElements = _ref.novalidateOnElements;\\n                         var prevent_implicit_submit = _ref.prevent_implicit_submit;\\n                         var preventImplicitSubmit = _ref.preventImplicitSubmit;\\n                         var revalidate = _ref.revalidate;\\n                         var _ref$strict = _ref.strict;\\n                         var strict = _ref$strict === undefined ? false : _ref$strict;\\n                         var valid_event = _ref.valid_event;\\n                         var validEvent = _ref.validEvent;\\n\\n\\n                         if (!classes) {\\n                           classes = {};\\n                         }\\n                         // TODO: clean up before next non-patch release\\n                         if (extendFieldset === undefined) {\\n                           if (extend_fieldset === undefined) {\\n                             extendFieldset = !strict;\\n                           } else {\\n                             w('extend_fieldset');\\n                             extendFieldset = extend_fieldset;\\n                           }\\n                         }\\n                         if (novalidateOnElements === undefined) {\\n                           if (novalidate_on_elements === undefined) {\\n                             novalidateOnElements = !strict;\\n                           } else {\\n                             w('novalidate_on_elements');\\n                             novalidateOnElements = novalidate_on_elements;\\n                           }\\n                         }\\n                         if (preventImplicitSubmit === undefined) {\\n                           if (prevent_implicit_submit === undefined) {\\n                             preventImplicitSubmit = false;\\n                           } else {\\n                             w('prevent_implicit_submit');\\n                             preventImplicitSubmit = prevent_implicit_submit;\\n                           }\\n                         }\\n                         if (revalidate === undefined) {\\n                           /* other recognized values: 'oninput', 'onblur', 'onsubmit' and 'never' */\\n                           revalidate = strict ? 'onsubmit' : 'hybrid';\\n                         }\\n                         if (validEvent === undefined) {\\n                           if (valid_event === undefined) {\\n                             validEvent = !strict;\\n                           } else {\\n                             w('valid_event');\\n                             validEvent = valid_event;\\n                           }\\n                         }\\n\\n                         var settings = { debug: debug, strict: strict, preventImplicitSubmit: preventImplicitSubmit, revalidate: revalidate,\\n                           validEvent: validEvent, extendFieldset: extendFieldset, classes: classes };\\n\\n                         if (form instanceof window.NodeList || form instanceof window.HTMLCollection || form instanceof Array) {\\n                           return Array.prototype.map.call(form, function (element) {\\n                             return hyperform(element, settings);\\n                           });\\n                         }\\n\\n                         return new Wrapper(form, settings);\\n                       }\\n\\n                       hyperform.version = version;\\n\\n                       hyperform.checkValidity = checkValidity;\\n                       hyperform.reportValidity = reportValidity;\\n                       hyperform.setCustomValidity = setCustomValidity;\\n                       hyperform.stepDown = stepDown;\\n                       hyperform.stepUp = stepUp;\\n                       hyperform.validationMessage = validationMessage;\\n                       hyperform.ValidityState = ValidityState;\\n                       hyperform.valueAsDate = valueAsDate;\\n                       hyperform.valueAsNumber = valueAsNumber;\\n                       hyperform.willValidate = willValidate;\\n\\n                       hyperform.setLanguage = function (lang) {\\n                         set_language(lang);return hyperform;\\n                       };\\n                       hyperform.addTranslation = function (lang, catalog) {\\n                         add_translation(lang, catalog);return hyperform;\\n                       };\\n                       hyperform.setRenderer = function (renderer, action) {\\n                         Renderer.set(renderer, action);return hyperform;\\n                       };\\n                       hyperform.addValidator = function (element, validator) {\\n                         custom_validator_registry.set(element, validator);return hyperform;\\n                       };\\n                       hyperform.setMessage = function (element, validator, message) {\\n                         custom_messages.set(element, validator, message);return hyperform;\\n                       };\\n                       hyperform.addHook = function (hook, action, position) {\\n                         add_hook(hook, action, position);return hyperform;\\n                       };\\n                       hyperform.removeHook = function (hook, action) {\\n                         remove_hook(hook, action);return hyperform;\\n                       };\\n\\n                       // TODO: Remove in next non-patch version\\n                       hyperform.set_language = function (lang) {\\n                         w('set_language');set_language(lang);return hyperform;\\n                       };\\n                       hyperform.add_translation = function (lang, catalog) {\\n                         w('add_translation');add_translation(lang, catalog);return hyperform;\\n                       };\\n                       hyperform.set_renderer = function (renderer, action) {\\n                         w('set_renderer');Renderer.set(renderer, action);return hyperform;\\n                       };\\n                       hyperform.add_validator = function (element, validator) {\\n                         w('add_validator');custom_validator_registry.set(element, validator);return hyperform;\\n                       };\\n                       hyperform.set_message = function (element, validator, message) {\\n                         w('set_message');custom_messages.set(element, validator, message);return hyperform;\\n                       };\\n                       hyperform.add_hook = function (hook, action, position) {\\n                         w('add_hook');add_hook(hook, action, position);return hyperform;\\n                       };\\n                       hyperform.remove_hook = function (hook, action) {\\n                         w('remove_hook');remove_hook(hook, action);return hyperform;\\n                       };\\n\\n                       if (document.currentScript && document.currentScript.hasAttribute('data-hf-autoload')) {\\n                         hyperform(window);\\n                       }\\n\\n                       return hyperform;\\n\\n}());\"\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(11)(__webpack_require__(10))\n\n/***/ })\n],[4]);\n\n\n// WEBPACK FOOTER //\n// main.7145370851ed51db7cef.js","/**\n * Form validation\n *\n * @since 1.0.0\n */\nimport 'script-loader!hyperform/dist/hyperform.js'\n\nconst FormValidation = () => {\n  window.hyperform(window)\n  const inputs = document.querySelectorAll('input')\n  ;[...inputs].forEach(input => {\n    if (input.required) {\n      input.addEventListener('invalid', e => e.preventDefault())\n    }\n  })\n}\n\nexport default FormValidation\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/FormValidation.js","/**\n * Main.js\n *\n * @since 1.0.0\n */\n\nimport FormValidation from './modules/FormValidation'\n\n;(function IIFE () {\n  FormValidation()\n})()\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/main.js","module.exports = \"/*! hyperform.js.org */\\nvar hyperform = (function () {\\n                       'use strict';\\n\\n                       var registry = Object.create(null);\\n\\n                       /**\\n                        * run all actions registered for a hook\\n                        *\\n                        * Every action gets called with a state object as `this` argument and with the\\n                        * hook's call arguments as call arguments.\\n                        *\\n                        * @return mixed the returned value of the action calls or undefined\\n                        */\\n                       function call_hook(hook) {\\n                         var result;\\n                         var call_args = Array.prototype.slice.call(arguments, 1);\\n\\n                         if (hook in registry) {\\n                           result = registry[hook].reduce(function (args) {\\n\\n                             return function (previousResult, currentAction) {\\n                               var interimResult = currentAction.apply({\\n                                 state: previousResult,\\n                                 hook: hook\\n                               }, args);\\n                               return interimResult !== undefined ? interimResult : previousResult;\\n                             };\\n                           }(call_args), result);\\n                         }\\n\\n                         return result;\\n                       }\\n\\n                       /**\\n                        * Filter a value through hooked functions\\n                        *\\n                        * Allows for additional parameters:\\n                        * js> do_filter('foo', null, current_element)\\n                        */\\n                       function do_filter(hook, initial_value) {\\n                         var result = initial_value;\\n                         var call_args = Array.prototype.slice.call(arguments, 1);\\n\\n                         if (hook in registry) {\\n                           result = registry[hook].reduce(function (previousResult, currentAction) {\\n                             call_args[0] = previousResult;\\n                             var interimResult = currentAction.apply({\\n                               state: previousResult,\\n                               hook: hook\\n                             }, call_args);\\n                             return interimResult !== undefined ? interimResult : previousResult;\\n                           }, result);\\n                         }\\n\\n                         return result;\\n                       }\\n\\n                       /**\\n                        * remove an action again\\n                        */\\n                       function remove_hook(hook, action) {\\n                         if (hook in registry) {\\n                           for (var i = 0; i < registry[hook].length; i++) {\\n                             if (registry[hook][i] === action) {\\n                               registry[hook].splice(i, 1);\\n                               break;\\n                             }\\n                           }\\n                         }\\n                       }\\n                       /**\\n                        * add an action to a hook\\n                        */\\n                       function add_hook(hook, action, position) {\\n                         if (!(hook in registry)) {\\n                           registry[hook] = [];\\n                         }\\n                         if (position === undefined) {\\n                           position = registry[hook].length;\\n                         }\\n                         registry[hook].splice(position, 0, action);\\n                       }\\n\\n                       /**\\n                        * return either the data of a hook call or the result of action, if the\\n                        * former is undefined\\n                        *\\n                        * @return function a function wrapper around action\\n                        */\\n                       function return_hook_or (hook, action) {\\n                         return function () {\\n                           var data = call_hook(hook, Array.prototype.slice.call(arguments));\\n\\n                           if (data !== undefined) {\\n                             return data;\\n                           }\\n\\n                           return action.apply(this, arguments);\\n                         };\\n                       }\\n\\n                       /* the following code is borrowed from the WebComponents project, licensed\\n                        * under the BSD license. Source:\\n                        * <https://github.com/webcomponents/webcomponentsjs/blob/5283db1459fa2323e5bfc8b9b5cc1753ed85e3d0/src/WebComponents/dom.js#L53-L78>\\n                        */\\n                       // defaultPrevented is broken in IE.\\n                       // https://connect.microsoft.com/IE/feedback/details/790389/event-defaultprevented-returns-false-after-preventdefault-was-called\\n\\n                       var workingDefaultPrevented = function () {\\n                         var e = document.createEvent('Event');\\n                         e.initEvent('foo', true, true);\\n                         e.preventDefault();\\n                         return e.defaultPrevented;\\n                       }();\\n\\n                       if (!workingDefaultPrevented) {\\n                         (function () {\\n                           var origPreventDefault = window.Event.prototype.preventDefault;\\n                           window.Event.prototype.preventDefault = function () {\\n                             if (!this.cancelable) {\\n                               return;\\n                             }\\n\\n                             origPreventDefault.call(this);\\n\\n                             Object.defineProperty(this, 'defaultPrevented', {\\n                               get: function get() {\\n                                 return true;\\n                               },\\n                               configurable: true\\n                             });\\n                           };\\n                         })();\\n                       }\\n                       /* end of borrowed code */\\n\\n                       function create_event(name) {\\n                         var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n                         var _ref$bubbles = _ref.bubbles;\\n                         var bubbles = _ref$bubbles === undefined ? true : _ref$bubbles;\\n                         var _ref$cancelable = _ref.cancelable;\\n                         var cancelable = _ref$cancelable === undefined ? false : _ref$cancelable;\\n\\n                         var event = document.createEvent('Event');\\n                         event.initEvent(name, bubbles, cancelable);\\n                         return event;\\n                       }\\n\\n                       function trigger_event (element, event) {\\n                         var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\\n\\n                         var _ref2$bubbles = _ref2.bubbles;\\n                         var bubbles = _ref2$bubbles === undefined ? true : _ref2$bubbles;\\n                         var _ref2$cancelable = _ref2.cancelable;\\n                         var cancelable = _ref2$cancelable === undefined ? false : _ref2$cancelable;\\n                         var payload = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\\n\\n                         if (!(event instanceof window.Event)) {\\n                           event = create_event(event, { bubbles: bubbles, cancelable: cancelable });\\n                         }\\n\\n                         for (var key in payload) {\\n                           if (payload.hasOwnProperty(key)) {\\n                             event[key] = payload[key];\\n                           }\\n                         }\\n\\n                         element.dispatchEvent(event);\\n\\n                         return event;\\n                       }\\n\\n                       /* and datetime-local? Spec says “Nah!” */\\n\\n                       var dates = ['datetime', 'date', 'month', 'week', 'time'];\\n\\n                       var plain_numbers = ['number', 'range'];\\n\\n                       /* everything that returns something meaningful for valueAsNumber and\\n                        * can have the step attribute */\\n                       var numbers = dates.concat(plain_numbers, 'datetime-local');\\n\\n                       /* the spec says to only check those for syntax in validity.typeMismatch.\\n                        * ¯\\\\_(ツ)_/¯ */\\n                       var type_checked = ['email', 'url'];\\n\\n                       /* check these for validity.badInput */\\n                       var input_checked = ['email', 'date', 'month', 'week', 'time', 'datetime', 'datetime-local', 'number', 'range', 'color'];\\n\\n                       var text_types = ['text', 'search', 'tel', 'password'].concat(type_checked);\\n\\n                       /* input element types, that are candidates for the validation API.\\n                        * Missing from this set are: button, hidden, menu (from <button>), reset and\\n                        * the types for non-<input> elements. */\\n                       var validation_candidates = ['checkbox', 'color', 'file', 'image', 'radio', 'submit'].concat(numbers, text_types);\\n\\n                       /* all known types of <input> */\\n                       var inputs = ['button', 'hidden', 'reset'].concat(validation_candidates);\\n\\n                       /* apparently <select> and <textarea> have types of their own */\\n                       var non_inputs = ['select-one', 'select-multiple', 'textarea'];\\n\\n                       /* shim layer for the Element.matches method */\\n\\n                       var ep = window.Element.prototype;\\n                       var native_matches = ep.matches || ep.matchesSelector || ep.msMatchesSelector || ep.webkitMatchesSelector;\\n\\n                       function matches (element, selector) {\\n                                              return native_matches.call(element, selector);\\n                       }\\n\\n                       /**\\n                        * mark an object with a '__hyperform=true' property\\n                        *\\n                        * We use this to distinguish our properties from the native ones. Usage:\\n                        * js> mark(obj);\\n                        * js> assert(obj.__hyperform === true)\\n                        */\\n\\n                       function mark (obj) {\\n                         if (['object', 'function'].indexOf(typeof obj) > -1) {\\n                           delete obj.__hyperform;\\n                           Object.defineProperty(obj, '__hyperform', {\\n                             configurable: true,\\n                             enumerable: false,\\n                             value: true\\n                           });\\n                         }\\n\\n                         return obj;\\n                       }\\n\\n                       /**\\n                        * the internal storage for messages\\n                        */\\n                       var store = new WeakMap();\\n\\n                       /* jshint -W053 */\\n                       var message_store = {\\n                         set: function set(element, message) {\\n                           var is_custom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\\n\\n                           if (element instanceof window.HTMLFieldSetElement) {\\n                             var wrapped_form = get_wrapper(element);\\n                             if (wrapped_form && !wrapped_form.settings.extendFieldset) {\\n                               /* make this a no-op for <fieldset> in strict mode */\\n                               return message_store;\\n                             }\\n                           }\\n\\n                           if (typeof message === 'string') {\\n                             message = new String(message);\\n                           }\\n                           if (is_custom) {\\n                             message.is_custom = true;\\n                           }\\n                           mark(message);\\n                           store.set(element, message);\\n\\n                           /* allow the :invalid selector to match */\\n                           if ('_original_setCustomValidity' in element) {\\n                             element._original_setCustomValidity(message.toString());\\n                           }\\n\\n                           return message_store;\\n                         },\\n                         get: function get(element) {\\n                           var message = store.get(element);\\n                           if (message === undefined && '_original_validationMessage' in element) {\\n                             /* get the browser's validation message, if we have none. Maybe it\\n                              * knows more than we. */\\n                             message = new String(element._original_validationMessage);\\n                           }\\n                           return message ? message : new String('');\\n                         },\\n                         delete: function _delete(element) {\\n                           if ('_original_setCustomValidity' in element) {\\n                             element._original_setCustomValidity('');\\n                           }\\n                           return store.delete(element);\\n                         }\\n                       };\\n\\n                       /**\\n                        * counter that will be incremented with every call\\n                        *\\n                        * Will enforce uniqueness, as long as no more than 1 hyperform scripts\\n                        * are loaded. (In that case we still have the \\\"random\\\" part below.)\\n                        */\\n\\n                       var uid = 0;\\n\\n                       /**\\n                        * generate a random ID\\n                        *\\n                        * @see https://gist.github.com/gordonbrander/2230317\\n                        */\\n                       function generate_id () {\\n                         var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hf_';\\n\\n                         return prefix + uid++ + Math.random().toString(36).substr(2);\\n                       }\\n\\n                       var warningsCache = new WeakMap();\\n\\n                       var DefaultRenderer = {\\n\\n                         /**\\n                          * called when a warning should become visible\\n                          */\\n                         attachWarning: function attachWarning(warning, element) {\\n                           /* should also work, if element is last,\\n                            * http://stackoverflow.com/a/4793630/113195 */\\n                           element.parentNode.insertBefore(warning, element.nextSibling);\\n                         },\\n\\n                         /**\\n                          * called when a warning should vanish\\n                          */\\n                         detachWarning: function detachWarning(warning, element) {\\n                           warning.parentNode.removeChild(warning);\\n                         },\\n\\n                         /**\\n                          * called when feedback to an element's state should be handled\\n                          *\\n                          * i.e., showing and hiding warnings\\n                          */\\n                         showWarning: function showWarning(element) {\\n                           var sub_radio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n                           var msg = message_store.get(element).toString();\\n                           var warning = warningsCache.get(element);\\n\\n                           if (msg) {\\n                             if (!warning) {\\n                               var wrapper = get_wrapper(element);\\n                               warning = document.createElement('div');\\n                               warning.className = wrapper && wrapper.settings.classes.warning || 'hf-warning';\\n                               warning.id = generate_id();\\n                               warning.setAttribute('aria-live', 'polite');\\n                               warningsCache.set(element, warning);\\n                             }\\n\\n                             element.setAttribute('aria-errormessage', warning.id);\\n                             warning.textContent = msg;\\n                             Renderer.attachWarning(warning, element);\\n                           } else if (warning && warning.parentNode) {\\n                             element.removeAttribute('aria-errormessage');\\n                             Renderer.detachWarning(warning, element);\\n                           }\\n\\n                           if (!sub_radio && element.type === 'radio' && element.form) {\\n                             /* render warnings for all other same-name radios, too */\\n                             Array.prototype.filter.call(document.getElementsByName(element.name), function (radio) {\\n                               return radio.name === element.name && radio.form === element.form;\\n                             }).map(function (radio) {\\n                               return Renderer.showWarning(radio, 'sub_radio');\\n                             });\\n                           }\\n                         }\\n\\n                       };\\n\\n                       var Renderer = {\\n\\n                         attachWarning: DefaultRenderer.attachWarning,\\n                         detachWarning: DefaultRenderer.detachWarning,\\n                         showWarning: DefaultRenderer.showWarning,\\n\\n                         set: function set(renderer, action) {\\n                           if (renderer.indexOf('_') > -1) {\\n                             /* global console */\\n                             // TODO delete before next non-patch version\\n                             console.log('Renderer.set: please use camelCase names. ' + renderer + ' will be removed in the next non-patch release.');\\n                             renderer = renderer.replace(/_([a-z])/g, function (g) {\\n                               return g[1].toUpperCase();\\n                             });\\n                           }\\n                           if (!action) {\\n                             action = DefaultRenderer[renderer];\\n                           }\\n                           Renderer[renderer] = action;\\n                         }\\n\\n                       };\\n\\n                       /**\\n                        * check element's validity and report an error back to the user\\n                        */\\n                       function reportValidity(element) {\\n                         /* if this is a <form>, report validity of all child inputs */\\n                         if (element instanceof window.HTMLFormElement) {\\n                           return Array.prototype.map.call(element.elements, reportValidity).every(function (b) {\\n                             return b;\\n                           });\\n                         }\\n\\n                         /* we copy checkValidity() here, b/c we have to check if the \\\"invalid\\\"\\n                          * event was canceled. */\\n                         var valid = ValidityState(element).valid;\\n                         var event;\\n                         if (valid) {\\n                           var wrapped_form = get_wrapper(element);\\n                           if (wrapped_form && wrapped_form.settings.validEvent) {\\n                             event = trigger_event(element, 'valid', { cancelable: true });\\n                           }\\n                         } else {\\n                           event = trigger_event(element, 'invalid', { cancelable: true });\\n                         }\\n\\n                         if (!event || !event.defaultPrevented) {\\n                           Renderer.showWarning(element);\\n                         }\\n\\n                         return valid;\\n                       }\\n\\n                       /**\\n                        * submit a form, because `element` triggered it\\n                        *\\n                        * This method also dispatches a submit event on the form prior to the\\n                        * submission. The event contains the trigger element as `submittedVia`.\\n                        *\\n                        * If the element is a button with a name, the name=value pair will be added\\n                        * to the submitted data.\\n                        */\\n                       function submit_form_via(element) {\\n                         /* apparently, the submit event is not triggered in most browsers on\\n                          * the submit() method, so we do it manually here to model a natural\\n                          * submit as closely as possible.\\n                          * Now to the fun fact: If you trigger a submit event from a form, what\\n                          * do you think should happen?\\n                          * 1) the form will be automagically submitted by the browser, or\\n                          * 2) nothing.\\n                          * And as you already suspected, the correct answer is: both! Firefox\\n                          * opts for 1), Chrome for 2). Yay! */\\n                         var event_got_cancelled;\\n\\n                         var submit_event = create_event('submit', { cancelable: true });\\n                         /* force Firefox to not submit the form, then fake preventDefault() */\\n                         submit_event.preventDefault();\\n                         Object.defineProperty(submit_event, 'defaultPrevented', {\\n                           value: false,\\n                           writable: true\\n                         });\\n                         Object.defineProperty(submit_event, 'preventDefault', {\\n                           value: function value() {\\n                             return submit_event.defaultPrevented = event_got_cancelled = true;\\n                           },\\n                           writable: true\\n                         });\\n                         trigger_event(element.form, submit_event, {}, { submittedVia: element });\\n\\n                         if (!event_got_cancelled) {\\n                           add_submit_field(element);\\n                           window.HTMLFormElement.prototype.submit.call(element.form);\\n                           window.setTimeout(function () {\\n                             return remove_submit_field(element);\\n                           });\\n                         }\\n                       }\\n\\n                       /**\\n                        * if a submit button was clicked, add its name=value by means of a type=hidden\\n                        * input field\\n                        */\\n                       function add_submit_field(button) {\\n                         if (['image', 'submit'].indexOf(button.type) > -1 && button.name) {\\n                           var wrapper = get_wrapper(button.form) || {};\\n                           var submit_helper = wrapper.submit_helper;\\n                           if (submit_helper) {\\n                             if (submit_helper.parentNode) {\\n                               submit_helper.parentNode.removeChild(submit_helper);\\n                             }\\n                           } else {\\n                             submit_helper = document.createElement('input');\\n                             submit_helper.type = 'hidden';\\n                             wrapper.submit_helper = submit_helper;\\n                           }\\n                           submit_helper.name = button.name;\\n                           submit_helper.value = button.value;\\n                           button.form.appendChild(submit_helper);\\n                         }\\n                       }\\n\\n                       /**\\n                        * remove a possible helper input, that was added by `add_submit_field`\\n                        */\\n                       function remove_submit_field(button) {\\n                         if (['image', 'submit'].indexOf(button.type) > -1 && button.name) {\\n                           var wrapper = get_wrapper(button.form) || {};\\n                           var submit_helper = wrapper.submit_helper;\\n                           if (submit_helper && submit_helper.parentNode) {\\n                             submit_helper.parentNode.removeChild(submit_helper);\\n                           }\\n                         }\\n                       }\\n\\n                       /**\\n                        * check a form's validity and submit it\\n                        *\\n                        * The method triggers a cancellable `validate` event on the form. If the\\n                        * event is cancelled, form submission will be aborted, too.\\n                        *\\n                        * If the form is found to contain invalid fields, focus the first field.\\n                        */\\n                       function check(button) {\\n                         /* trigger a \\\"validate\\\" event on the form to be submitted */\\n                         var val_event = trigger_event(button.form, 'validate', { cancelable: true });\\n                         if (val_event.defaultPrevented) {\\n                           /* skip the whole submit thing, if the validation is canceled. A user\\n                            * can still call form.submit() afterwards. */\\n                           return;\\n                         }\\n\\n                         var valid = true;\\n                         var first_invalid;\\n                         Array.prototype.map.call(button.form.elements, function (element) {\\n                           if (!reportValidity(element)) {\\n                             valid = false;\\n                             if (!first_invalid && 'focus' in element) {\\n                               first_invalid = element;\\n                             }\\n                           }\\n                         });\\n\\n                         if (valid) {\\n                           submit_form_via(button);\\n                         } else if (first_invalid) {\\n                           /* focus the first invalid element, if validation went south */\\n                           first_invalid.focus();\\n                           /* tell the tale, if anyone wants to react to it */\\n                           trigger_event(button.form, 'forminvalid');\\n                         }\\n                       }\\n\\n                       /**\\n                        * test if node is a submit button\\n                        */\\n                       function is_submit_button(node) {\\n                         return (\\n                           /* must be an input or button element... */\\n                           (node.nodeName === 'INPUT' || node.nodeName === 'BUTTON') && (\\n\\n                           /* ...and have a submitting type */\\n                           node.type === 'image' || node.type === 'submit')\\n                         );\\n                       }\\n\\n                       /**\\n                        * test, if the click event would trigger a submit\\n                        */\\n                       function is_submitting_click(event, button) {\\n                         return (\\n                           /* prevented default: won't trigger a submit */\\n                           !event.defaultPrevented && (\\n\\n                           /* left button or middle button (submits in Chrome) */\\n                           !('button' in event) || event.button < 2) &&\\n\\n                           /* must be a submit button... */\\n                           is_submit_button(button) &&\\n\\n                           /* the button needs a form, that's going to be submitted */\\n                           button.form &&\\n\\n                           /* again, if the form should not be validated, we're out of the game */\\n                           !button.form.hasAttribute('novalidate')\\n                         );\\n                       }\\n\\n                       /**\\n                        * test, if the keypress event would trigger a submit\\n                        */\\n                       function is_submitting_keypress(event) {\\n                         return (\\n                           /* prevented default: won't trigger a submit */\\n                           !event.defaultPrevented && (\\n                           /* ...and <Enter> was pressed... */\\n                           event.keyCode === 13 &&\\n\\n                           /* ...on an <input> that is... */\\n                           event.target.nodeName === 'INPUT' &&\\n\\n                           /* ...a standard text input field (not checkbox, ...) */\\n                           text_types.indexOf(event.target.type) > -1 ||\\n                           /* or <Enter> or <Space> was pressed... */\\n                           (event.keyCode === 13 || event.keyCode === 32) &&\\n\\n                           /* ...on a submit button */\\n                           is_submit_button(event.target)) &&\\n\\n                           /* there's a form... */\\n                           event.target.form &&\\n\\n                           /* ...and the form allows validation */\\n                           !event.target.form.hasAttribute('novalidate')\\n                         );\\n                       }\\n\\n                       /**\\n                        * catch clicks to children of <button>s\\n                        */\\n                       function get_clicked_button(element) {\\n                         if (is_submit_button(element)) {\\n                           return element;\\n                         } else if (matches(element, 'button:not([type]) *, button[type=\\\"submit\\\"] *')) {\\n                           return get_clicked_button(element.parentNode);\\n                         } else {\\n                           return null;\\n                         }\\n                       }\\n\\n                       /**\\n                        * return event handler to catch explicit submission by click on a button\\n                        */\\n                       function get_click_handler() {\\n                         var ignore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n                         return function (event) {\\n                           var button = get_clicked_button(event.target);\\n                           if (button && is_submitting_click(event, button)) {\\n                             event.preventDefault();\\n                             if (ignore || button.hasAttribute('formnovalidate')) {\\n                               /* if validation should be ignored, we're not interested in any checks */\\n                               submit_form_via(button);\\n                             } else {\\n                               check(button);\\n                             }\\n                           }\\n                         };\\n                       }\\n                       var click_handler = get_click_handler();\\n                       var ignored_click_handler = get_click_handler(true);\\n\\n                       /**\\n                        * catch implicit submission by pressing <Enter> in some situations\\n                        */\\n                       function get_keypress_handler(ignore) {\\n                         return function keypress_handler(event) {\\n                           if (is_submitting_keypress(event)) {\\n                             event.preventDefault();\\n\\n                             var wrapper = get_wrapper(event.target.form) || { settings: {} };\\n                             if (wrapper.settings.preventImplicitSubmit) {\\n                               /* user doesn't want an implicit submit. Cancel here. */\\n                               return;\\n                             }\\n\\n                             /* check, that there is no submit button in the form. Otherwise\\n                             * that should be clicked. */\\n                             var el = event.target.form.elements.length;\\n                             var submit;\\n                             for (var i = 0; i < el; i++) {\\n                               if (['image', 'submit'].indexOf(event.target.form.elements[i].type) > -1) {\\n                                 submit = event.target.form.elements[i];\\n                                 break;\\n                               }\\n                             }\\n\\n                             if (submit) {\\n                               submit.click();\\n                             } else if (ignore) {\\n                               submit_form_via(event.target);\\n                             } else {\\n                               check(event.target);\\n                             }\\n                           }\\n                         };\\n                       }\\n                       var keypress_handler = get_keypress_handler();\\n                       var ignored_keypress_handler = get_keypress_handler(true);\\n\\n                       /**\\n                        * catch all relevant events _prior_ to a form being submitted\\n                        *\\n                        * @param bool ignore bypass validation, when an attempt to submit the\\n                        *                    form is detected. True, when the wrapper's revalidate\\n                        *                    setting is 'never'.\\n                        */\\n                       function catch_submit(listening_node) {\\n                         var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n                         if (ignore) {\\n                           listening_node.addEventListener('click', ignored_click_handler);\\n                           listening_node.addEventListener('keypress', ignored_keypress_handler);\\n                         } else {\\n                           listening_node.addEventListener('click', click_handler);\\n                           listening_node.addEventListener('keypress', keypress_handler);\\n                         }\\n                       }\\n\\n                       /**\\n                        * decommission the event listeners from catch_submit() again\\n                        */\\n                       function uncatch_submit(listening_node) {\\n                         listening_node.removeEventListener('click', ignored_click_handler);\\n                         listening_node.removeEventListener('keypress', ignored_keypress_handler);\\n                         listening_node.removeEventListener('click', click_handler);\\n                         listening_node.removeEventListener('keypress', keypress_handler);\\n                       }\\n\\n                       /**\\n                        * remove `property` from element and restore _original_property, if present\\n                        */\\n                       function uninstall_property (element, property) {\\n                         try {\\n                           delete element[property];\\n                         } catch (e) {\\n                           /* Safari <= 9 and PhantomJS will end up here :-( Nothing to do except\\n                            * warning */\\n                           var wrapper = get_wrapper(element);\\n                           if (wrapper && wrapper.settings.debug) {\\n                             /* global console */\\n                             console.log('[hyperform] cannot uninstall custom property ' + property);\\n                           }\\n                           return false;\\n                         }\\n\\n                         var original_descriptor = Object.getOwnPropertyDescriptor(element, '_original_' + property);\\n\\n                         if (original_descriptor) {\\n                           Object.defineProperty(element, property, original_descriptor);\\n                         }\\n                       }\\n\\n                       /**\\n                        * add `property` to an element\\n                        *\\n                        * js> installer(element, 'foo', { value: 'bar' });\\n                        * js> assert(element.foo === 'bar');\\n                        */\\n                       function install_property (element, property, descriptor) {\\n                         descriptor.configurable = true;\\n                         descriptor.enumerable = true;\\n                         if ('value' in descriptor) {\\n                           descriptor.writable = true;\\n                         }\\n\\n                         var original_descriptor = Object.getOwnPropertyDescriptor(element, property);\\n\\n                         if (original_descriptor) {\\n\\n                           if (original_descriptor.configurable === false) {\\n                             /* Safari <= 9 and PhantomJS will end up here :-( Nothing to do except\\n                              * warning */\\n                             var wrapper = get_wrapper(element);\\n                             if (wrapper && wrapper.settings.debug) {\\n                               /* global console */\\n                               console.log('[hyperform] cannot install custom property ' + property);\\n                             }\\n                             return false;\\n                           }\\n\\n                           /* we already installed that property... */\\n                           if (original_descriptor.get && original_descriptor.get.__hyperform || original_descriptor.value && original_descriptor.value.__hyperform) {\\n                             return;\\n                           }\\n\\n                           /* publish existing property under new name, if it's not from us */\\n                           Object.defineProperty(element, '_original_' + property, original_descriptor);\\n                         }\\n\\n                         delete element[property];\\n                         Object.defineProperty(element, property, descriptor);\\n\\n                         return true;\\n                       }\\n\\n                       function is_field (element) {\\n                               return element instanceof window.HTMLButtonElement || element instanceof window.HTMLInputElement || element instanceof window.HTMLSelectElement || element instanceof window.HTMLTextAreaElement || element instanceof window.HTMLFieldSetElement || element === window.HTMLButtonElement.prototype || element === window.HTMLInputElement.prototype || element === window.HTMLSelectElement.prototype || element === window.HTMLTextAreaElement.prototype || element === window.HTMLFieldSetElement.prototype;\\n                       }\\n\\n                       /**\\n                        * set a custom validity message or delete it with an empty string\\n                        */\\n                       function setCustomValidity(element, msg) {\\n                         message_store.set(element, msg, true);\\n                       }\\n\\n                       function sprintf (str) {\\n                         for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n                           args[_key - 1] = arguments[_key];\\n                         }\\n\\n                         var args_length = args.length;\\n                         var global_index = 0;\\n\\n                         return str.replace(/%([0-9]+\\\\$)?([sl])/g, function (match, position, type) {\\n                           var local_index = global_index;\\n                           if (position) {\\n                             local_index = Number(position.replace(/\\\\$$/, '')) - 1;\\n                           }\\n                           global_index += 1;\\n\\n                           var arg = '';\\n                           if (args_length > local_index) {\\n                             arg = args[local_index];\\n                           }\\n\\n                           if (arg instanceof Date || typeof arg === 'number' || arg instanceof Number) {\\n                             /* try getting a localized representation of dates and numbers, if the\\n                              * browser supports this */\\n                             if (type === 'l') {\\n                               arg = (arg.toLocaleString || arg.toString).call(arg);\\n                             } else {\\n                               arg = arg.toString();\\n                             }\\n                           }\\n\\n                           return arg;\\n                         });\\n                       }\\n\\n                       /* For a given date, get the ISO week number\\n                        *\\n                        * Source: http://stackoverflow.com/a/6117889/113195\\n                        *\\n                        * Based on information at:\\n                        *\\n                        *    http://www.merlyn.demon.co.uk/weekcalc.htm#WNR\\n                        *\\n                        * Algorithm is to find nearest thursday, it's year\\n                        * is the year of the week number. Then get weeks\\n                        * between that date and the first day of that year.\\n                        *\\n                        * Note that dates in one year can be weeks of previous\\n                        * or next year, overlap is up to 3 days.\\n                        *\\n                        * e.g. 2014/12/29 is Monday in week  1 of 2015\\n                        *      2012/1/1   is Sunday in week 52 of 2011\\n                        */\\n\\n                       function get_week_of_year (d) {\\n                         /* Copy date so don't modify original */\\n                         d = new Date(+d);\\n                         d.setUTCHours(0, 0, 0);\\n                         /* Set to nearest Thursday: current date + 4 - current day number\\n                          * Make Sunday's day number 7 */\\n                         d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));\\n                         /* Get first day of year */\\n                         var yearStart = new Date(d.getUTCFullYear(), 0, 1);\\n                         /* Calculate full weeks to nearest Thursday */\\n                         var weekNo = Math.ceil(((d - yearStart) / 86400000 + 1) / 7);\\n                         /* Return array of year and week number */\\n                         return [d.getUTCFullYear(), weekNo];\\n                       }\\n\\n                       function pad(num) {\\n                         var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\\n\\n                         var s = num + '';\\n                         while (s.length < size) {\\n                           s = '0' + s;\\n                         }\\n                         return s;\\n                       }\\n\\n                       /**\\n                        * calculate a string from a date according to HTML5\\n                        */\\n                       function date_to_string(date, element_type) {\\n                         if (!(date instanceof Date)) {\\n                           return null;\\n                         }\\n\\n                         switch (element_type) {\\n                           case 'datetime':\\n                             return date_to_string(date, 'date') + 'T' + date_to_string(date, 'time');\\n\\n                           case 'datetime-local':\\n                             return sprintf('%s-%s-%sT%s:%s:%s.%s', date.getFullYear(), pad(date.getMonth() + 1), pad(date.getDate()), pad(date.getHours()), pad(date.getMinutes()), pad(date.getSeconds()), pad(date.getMilliseconds(), 3)).replace(/(:00)?\\\\.000$/, '');\\n\\n                           case 'date':\\n                             return sprintf('%s-%s-%s', date.getUTCFullYear(), pad(date.getUTCMonth() + 1), pad(date.getUTCDate()));\\n\\n                           case 'month':\\n                             return sprintf('%s-%s', date.getUTCFullYear(), pad(date.getUTCMonth() + 1));\\n\\n                           case 'week':\\n                             var params = get_week_of_year(date);\\n                             return sprintf.call(null, '%s-W%s', params[0], pad(params[1]));\\n\\n                           case 'time':\\n                             return sprintf('%s:%s:%s.%s', pad(date.getUTCHours()), pad(date.getUTCMinutes()), pad(date.getUTCSeconds()), pad(date.getUTCMilliseconds(), 3)).replace(/(:00)?\\\\.000$/, '');\\n                         }\\n\\n                         return null;\\n                       }\\n\\n                       /**\\n                        * return a new Date() representing the ISO date for a week number\\n                        *\\n                        * @see http://stackoverflow.com/a/16591175/113195\\n                        */\\n\\n                       function get_date_from_week (week, year) {\\n                         var date = new Date(Date.UTC(year, 0, 1 + (week - 1) * 7));\\n\\n                         if (date.getUTCDay() <= 4 /* thursday */) {\\n                             date.setUTCDate(date.getUTCDate() - date.getUTCDay() + 1);\\n                           } else {\\n                           date.setUTCDate(date.getUTCDate() + 8 - date.getUTCDay());\\n                         }\\n\\n                         return date;\\n                       }\\n\\n                       /**\\n                        * calculate a date from a string according to HTML5\\n                        */\\n                       function string_to_date (string, element_type) {\\n                         var date = new Date(0);\\n                         var ms;\\n                         switch (element_type) {\\n                           case 'datetime':\\n                             if (!/^([0-9]{4,})-([0-9]{2})-([0-9]{2})T([01][0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9])(?:\\\\.([0-9]{1,3}))?)?$/.test(string)) {\\n                               return null;\\n                             }\\n                             ms = RegExp.$7 || '000';\\n                             while (ms.length < 3) {\\n                               ms += '0';\\n                             }\\n                             date.setUTCFullYear(Number(RegExp.$1));\\n                             date.setUTCMonth(Number(RegExp.$2) - 1, Number(RegExp.$3));\\n                             date.setUTCHours(Number(RegExp.$4), Number(RegExp.$5), Number(RegExp.$6 || 0), Number(ms));\\n                             return date;\\n\\n                           case 'date':\\n                             if (!/^([0-9]{4,})-([0-9]{2})-([0-9]{2})$/.test(string)) {\\n                               return null;\\n                             }\\n                             date.setUTCFullYear(Number(RegExp.$1));\\n                             date.setUTCMonth(Number(RegExp.$2) - 1, Number(RegExp.$3));\\n                             return date;\\n\\n                           case 'month':\\n                             if (!/^([0-9]{4,})-([0-9]{2})$/.test(string)) {\\n                               return null;\\n                             }\\n                             date.setUTCFullYear(Number(RegExp.$1));\\n                             date.setUTCMonth(Number(RegExp.$2) - 1, 1);\\n                             return date;\\n\\n                           case 'week':\\n                             if (!/^([0-9]{4,})-W(0[1-9]|[1234][0-9]|5[0-3])$/.test(string)) {\\n                               return null;\\n                             }\\n                             return get_date_from_week(Number(RegExp.$2), Number(RegExp.$1));\\n\\n                           case 'time':\\n                             if (!/^([01][0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9])(?:\\\\.([0-9]{1,3}))?)?$/.test(string)) {\\n                               return null;\\n                             }\\n                             ms = RegExp.$4 || '000';\\n                             while (ms.length < 3) {\\n                               ms += '0';\\n                             }\\n                             date.setUTCHours(Number(RegExp.$1), Number(RegExp.$2), Number(RegExp.$3 || 0), Number(ms));\\n                             return date;\\n                         }\\n\\n                         return null;\\n                       }\\n\\n                       /**\\n                        * calculate a date from a string according to HTML5\\n                        */\\n                       function string_to_number (string, element_type) {\\n                         var rval = string_to_date(string, element_type);\\n                         if (rval !== null) {\\n                           return +rval;\\n                         }\\n                         /* not parseFloat, because we want NaN for invalid values like \\\"1.2xxy\\\" */\\n                         return Number(string);\\n                       }\\n\\n                       /**\\n                        * get the element's type in a backwards-compatible way\\n                        */\\n                       function get_type (element) {\\n                         if (element instanceof window.HTMLTextAreaElement) {\\n                           return 'textarea';\\n                         } else if (element instanceof window.HTMLSelectElement) {\\n                           return element.hasAttribute('multiple') ? 'select-multiple' : 'select-one';\\n                         } else if (element instanceof window.HTMLButtonElement) {\\n                           return (element.getAttribute('type') || 'submit').toLowerCase();\\n                         } else if (element instanceof window.HTMLInputElement) {\\n                           var attr = (element.getAttribute('type') || '').toLowerCase();\\n                           if (attr && inputs.indexOf(attr) > -1) {\\n                             return attr;\\n                           } else {\\n                             /* perhaps the DOM has in-depth knowledge. Take that before returning\\n                              * 'text'. */\\n                             return element.type || 'text';\\n                           }\\n                         }\\n\\n                         return '';\\n                       }\\n\\n                       /**\\n                        * the following validation messages are from Firefox source,\\n                        * http://mxr.mozilla.org/mozilla-central/source/dom/locales/en-US/chrome/dom/dom.properties\\n                        * released under MPL license, http://mozilla.org/MPL/2.0/.\\n                        */\\n\\n                       var catalog = {\\n                         en: {\\n                           TextTooLong: 'Please shorten this text to %l characters or less (you are currently using %l characters).',\\n                           ValueMissing: 'Please fill out this field.',\\n                           CheckboxMissing: 'Please check this box if you want to proceed.',\\n                           RadioMissing: 'Please select one of these options.',\\n                           FileMissing: 'Please select a file.',\\n                           SelectMissing: 'Please select an item in the list.',\\n                           InvalidEmail: 'Please enter an email address.',\\n                           InvalidURL: 'Please enter a URL.',\\n                           PatternMismatch: 'Please match the requested format.',\\n                           PatternMismatchWithTitle: 'Please match the requested format: %l.',\\n                           NumberRangeOverflow: 'Please select a value that is no more than %l.',\\n                           DateRangeOverflow: 'Please select a value that is no later than %l.',\\n                           TimeRangeOverflow: 'Please select a value that is no later than %l.',\\n                           NumberRangeUnderflow: 'Please select a value that is no less than %l.',\\n                           DateRangeUnderflow: 'Please select a value that is no earlier than %l.',\\n                           TimeRangeUnderflow: 'Please select a value that is no earlier than %l.',\\n                           StepMismatch: 'Please select a valid value. The two nearest valid values are %l and %l.',\\n                           StepMismatchOneValue: 'Please select a valid value. The nearest valid value is %l.',\\n                           BadInputNumber: 'Please enter a number.'\\n                         }\\n                       };\\n\\n                       /**\\n                        * the global language Hyperform will use\\n                        */\\n                       var language = 'en';\\n\\n                       /**\\n                        * set the language for Hyperform’s messages\\n                        */\\n                       function set_language(newlang) {\\n                         language = newlang;\\n                       }\\n\\n                       /**\\n                        * add a lookup catalog \\\"string: translation\\\" for a language\\n                        */\\n                       function add_translation(lang, new_catalog) {\\n                         if (!(lang in catalog)) {\\n                           catalog[lang] = {};\\n                         }\\n                         for (var key in new_catalog) {\\n                           if (new_catalog.hasOwnProperty(key)) {\\n                             catalog[lang][key] = new_catalog[key];\\n                           }\\n                         }\\n                       }\\n\\n                       /**\\n                        * return `s` translated into the current language\\n                        *\\n                        * Defaults to English if the former has no translation for `s`.\\n                        */\\n                       function _ (s) {\\n                         if (language in catalog && s in catalog[language]) {\\n                           return catalog[language][s];\\n                         } else if (s in catalog.en) {\\n                           return catalog.en[s];\\n                         }\\n                         return s;\\n                       }\\n\\n                       var default_step = {\\n                         'datetime-local': 60,\\n                         datetime: 60,\\n                         time: 60\\n                       };\\n\\n                       var step_scale_factor = {\\n                         'datetime-local': 1000,\\n                         datetime: 1000,\\n                         date: 86400000,\\n                         week: 604800000,\\n                         time: 1000\\n                       };\\n\\n                       var default_step_base = {\\n                         week: -259200000\\n                       };\\n\\n                       var default_min = {\\n                         range: 0\\n                       };\\n\\n                       var default_max = {\\n                         range: 100\\n                       };\\n\\n                       /**\\n                        * get previous and next valid values for a stepped input element\\n                        */\\n                       function get_next_valid (element) {\\n                         var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n                         var type = get_type(element);\\n\\n                         var aMin = element.getAttribute('min');\\n                         var min = default_min[type] || NaN;\\n                         if (aMin) {\\n                           var pMin = string_to_number(aMin, type);\\n                           if (!isNaN(pMin)) {\\n                             min = pMin;\\n                           }\\n                         }\\n\\n                         var aMax = element.getAttribute('max');\\n                         var max = default_max[type] || NaN;\\n                         if (aMax) {\\n                           var pMax = string_to_number(aMax, type);\\n                           if (!isNaN(pMax)) {\\n                             max = pMax;\\n                           }\\n                         }\\n\\n                         var aStep = element.getAttribute('step');\\n                         var step = default_step[type] || 1;\\n                         if (aStep && aStep.toLowerCase() === 'any') {\\n                           /* quick return: we cannot calculate prev and next */\\n                           return [_('any value'), _('any value')];\\n                         } else if (aStep) {\\n                           var pStep = string_to_number(aStep, type);\\n                           if (!isNaN(pStep)) {\\n                             step = pStep;\\n                           }\\n                         }\\n\\n                         var default_value = string_to_number(element.getAttribute('value'), type);\\n\\n                         var value = string_to_number(element.value || element.getAttribute('value'), type);\\n\\n                         if (isNaN(value)) {\\n                           /* quick return: we cannot calculate without a solid base */\\n                           return [_('any valid value'), _('any valid value')];\\n                         }\\n\\n                         var step_base = !isNaN(min) ? min : !isNaN(default_value) ? default_value : default_step_base[type] || 0;\\n\\n                         var scale = step_scale_factor[type] || 1;\\n\\n                         var prev = step_base + Math.floor((value - step_base) / (step * scale)) * (step * scale) * n;\\n                         var next = step_base + (Math.floor((value - step_base) / (step * scale)) + 1) * (step * scale) * n;\\n\\n                         if (prev < min) {\\n                           prev = null;\\n                         } else if (prev > max) {\\n                           prev = max;\\n                         }\\n\\n                         if (next > max) {\\n                           next = null;\\n                         } else if (next < min) {\\n                           next = min;\\n                         }\\n\\n                         /* convert to date objects, if appropriate */\\n                         if (dates.indexOf(type) > -1) {\\n                           prev = date_to_string(new Date(prev), type);\\n                           next = date_to_string(new Date(next), type);\\n                         }\\n\\n                         return [prev, next];\\n                       }\\n\\n                       /**\\n                        * implement the valueAsDate functionality\\n                        *\\n                        * @see https://html.spec.whatwg.org/multipage/forms.html#dom-input-valueasdate\\n                        */\\n                       function valueAsDate(element) {\\n                         var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\\n\\n                         var type = get_type(element);\\n                         if (dates.indexOf(type) > -1) {\\n                           if (value !== undefined) {\\n                             /* setter: value must be null or a Date() */\\n                             if (value === null) {\\n                               element.value = '';\\n                             } else if (value instanceof Date) {\\n                               if (isNaN(value.getTime())) {\\n                                 element.value = '';\\n                               } else {\\n                                 element.value = date_to_string(value, type);\\n                               }\\n                             } else {\\n                               throw new window.DOMException('valueAsDate setter encountered invalid value', 'TypeError');\\n                             }\\n                             return;\\n                           }\\n\\n                           var value_date = string_to_date(element.value, type);\\n                           return value_date instanceof Date ? value_date : null;\\n                         } else if (value !== undefined) {\\n                           /* trying to set a date on a not-date input fails */\\n                           throw new window.DOMException('valueAsDate setter cannot set date on this element', 'InvalidStateError');\\n                         }\\n\\n                         return null;\\n                       }\\n\\n                       /**\\n                        * implement the valueAsNumber functionality\\n                        *\\n                        * @see https://html.spec.whatwg.org/multipage/forms.html#dom-input-valueasnumber\\n                        */\\n                       function valueAsNumber(element) {\\n                         var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\\n\\n                         var type = get_type(element);\\n                         if (numbers.indexOf(type) > -1) {\\n                           if (type === 'range' && element.hasAttribute('multiple')) {\\n                             /* @see https://html.spec.whatwg.org/multipage/forms.html#do-not-apply */\\n                             return NaN;\\n                           }\\n\\n                           if (value !== undefined) {\\n                             /* setter: value must be NaN or a finite number */\\n                             if (isNaN(value)) {\\n                               element.value = '';\\n                             } else if (typeof value === 'number' && window.isFinite(value)) {\\n                               try {\\n                                 /* try setting as a date, but... */\\n                                 valueAsDate(element, new Date(value));\\n                               } catch (e) {\\n                                 /* ... when valueAsDate is not responsible, ... */\\n                                 if (!(e instanceof window.DOMException)) {\\n                                   throw e;\\n                                 }\\n                                 /* ... set it via Number.toString(). */\\n                                 element.value = value.toString();\\n                               }\\n                             } else {\\n                               throw new window.DOMException('valueAsNumber setter encountered invalid value', 'TypeError');\\n                             }\\n                             return;\\n                           }\\n\\n                           return string_to_number(element.value, type);\\n                         } else if (value !== undefined) {\\n                           /* trying to set a number on a not-number input fails */\\n                           throw new window.DOMException('valueAsNumber setter cannot set number on this element', 'InvalidStateError');\\n                         }\\n\\n                         return NaN;\\n                       }\\n\\n                       /**\\n                        *\\n                        */\\n                       function stepDown(element) {\\n                         var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n                         if (numbers.indexOf(get_type(element)) === -1) {\\n                           throw new window.DOMException('stepDown encountered invalid type', 'InvalidStateError');\\n                         }\\n                         if ((element.getAttribute('step') || '').toLowerCase() === 'any') {\\n                           throw new window.DOMException('stepDown encountered step \\\"any\\\"', 'InvalidStateError');\\n                         }\\n\\n                         var prev = get_next_valid(element, n)[0];\\n\\n                         if (prev !== null) {\\n                           valueAsNumber(element, prev);\\n                         }\\n                       }\\n\\n                       /**\\n                        *\\n                        */\\n                       function stepUp(element) {\\n                         var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n                         if (numbers.indexOf(get_type(element)) === -1) {\\n                           throw new window.DOMException('stepUp encountered invalid type', 'InvalidStateError');\\n                         }\\n                         if ((element.getAttribute('step') || '').toLowerCase() === 'any') {\\n                           throw new window.DOMException('stepUp encountered step \\\"any\\\"', 'InvalidStateError');\\n                         }\\n\\n                         var next = get_next_valid(element, n)[1];\\n\\n                         if (next !== null) {\\n                           valueAsNumber(element, next);\\n                         }\\n                       }\\n\\n                       /**\\n                        * get the validation message for an element, empty string, if the element\\n                        * satisfies all constraints.\\n                        */\\n                       function validationMessage(element) {\\n                         var msg = message_store.get(element);\\n                         if (!msg) {\\n                           return '';\\n                         }\\n\\n                         /* make it a primitive again, since message_store returns String(). */\\n                         return msg.toString();\\n                       }\\n\\n                       /**\\n                        * check, if an element will be subject to HTML5 validation at all\\n                        */\\n                       function willValidate(element) {\\n                         return is_validation_candidate(element);\\n                       }\\n\\n                       var gA = function gA(prop) {\\n                         return function () {\\n                           return do_filter('attr_get_' + prop, this.getAttribute(prop), this);\\n                         };\\n                       };\\n\\n                       var sA = function sA(prop) {\\n                         return function (value) {\\n                           this.setAttribute(prop, do_filter('attr_set_' + prop, value, this));\\n                         };\\n                       };\\n\\n                       var gAb = function gAb(prop) {\\n                         return function () {\\n                           return do_filter('attr_get_' + prop, this.hasAttribute(prop), this);\\n                         };\\n                       };\\n\\n                       var sAb = function sAb(prop) {\\n                         return function (value) {\\n                           if (do_filter('attr_set_' + prop, value, this)) {\\n                             this.setAttribute(prop, prop);\\n                           } else {\\n                             this.removeAttribute(prop);\\n                           }\\n                         };\\n                       };\\n\\n                       var gAn = function gAn(prop) {\\n                         return function () {\\n                           return do_filter('attr_get_' + prop, Math.max(0, Number(this.getAttribute(prop))), this);\\n                         };\\n                       };\\n\\n                       var sAn = function sAn(prop) {\\n                         return function (value) {\\n                           value = do_filter('attr_set_' + prop, value, this);\\n                           if (/^[0-9]+$/.test(value)) {\\n                             this.setAttribute(prop, value);\\n                           }\\n                         };\\n                       };\\n\\n                       function install_properties(element) {\\n                         var _arr = ['accept', 'max', 'min', 'pattern', 'placeholder', 'step'];\\n\\n                         for (var _i = 0; _i < _arr.length; _i++) {\\n                           var prop = _arr[_i];\\n                           install_property(element, prop, {\\n                             get: gA(prop),\\n                             set: sA(prop)\\n                           });\\n                         }\\n\\n                         var _arr2 = ['multiple', 'required', 'readOnly'];\\n                         for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\\n                           var _prop = _arr2[_i2];\\n                           install_property(element, _prop, {\\n                             get: gAb(_prop.toLowerCase()),\\n                             set: sAb(_prop.toLowerCase())\\n                           });\\n                         }\\n\\n                         var _arr3 = ['minLength', 'maxLength'];\\n                         for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\\n                           var _prop2 = _arr3[_i3];\\n                           install_property(element, _prop2, {\\n                             get: gAn(_prop2.toLowerCase()),\\n                             set: sAn(_prop2.toLowerCase())\\n                           });\\n                         }\\n                       }\\n\\n                       function uninstall_properties(element) {\\n                         var _arr4 = ['accept', 'max', 'min', 'pattern', 'placeholder', 'step', 'multiple', 'required', 'readOnly', 'minLength', 'maxLength'];\\n\\n                         for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\\n                           var prop = _arr4[_i4];\\n                           uninstall_property(element, prop);\\n                         }\\n                       }\\n\\n                       var polyfills = {\\n                         checkValidity: {\\n                           value: mark(function () {\\n                             return checkValidity(this);\\n                           })\\n                         },\\n                         reportValidity: {\\n                           value: mark(function () {\\n                             return reportValidity(this);\\n                           })\\n                         },\\n                         setCustomValidity: {\\n                           value: mark(function (msg) {\\n                             return setCustomValidity(this, msg);\\n                           })\\n                         },\\n                         stepDown: {\\n                           value: mark(function () {\\n                             var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n                             return stepDown(this, n);\\n                           })\\n                         },\\n                         stepUp: {\\n                           value: mark(function () {\\n                             var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n                             return stepUp(this, n);\\n                           })\\n                         },\\n                         validationMessage: {\\n                           get: mark(function () {\\n                             return validationMessage(this);\\n                           })\\n                         },\\n                         validity: {\\n                           get: mark(function () {\\n                             return ValidityState(this);\\n                           })\\n                         },\\n                         valueAsDate: {\\n                           get: mark(function () {\\n                             return valueAsDate(this);\\n                           }),\\n                           set: mark(function (value) {\\n                             valueAsDate(this, value);\\n                           })\\n                         },\\n                         valueAsNumber: {\\n                           get: mark(function () {\\n                             return valueAsNumber(this);\\n                           }),\\n                           set: mark(function (value) {\\n                             valueAsNumber(this, value);\\n                           })\\n                         },\\n                         willValidate: {\\n                           get: mark(function () {\\n                             return willValidate(this);\\n                           })\\n                         }\\n                       };\\n\\n                       function polyfill (element) {\\n                         if (is_field(element)) {\\n\\n                           for (var prop in polyfills) {\\n                             install_property(element, prop, polyfills[prop]);\\n                           }\\n\\n                           install_properties(element);\\n                         } else if (element instanceof window.HTMLFormElement || element === window.HTMLFormElement.prototype) {\\n                           install_property(element, 'checkValidity', polyfills.checkValidity);\\n                           install_property(element, 'reportValidity', polyfills.reportValidity);\\n                         }\\n                       }\\n\\n                       function polyunfill (element) {\\n                         if (is_field(element)) {\\n\\n                           uninstall_property(element, 'checkValidity');\\n                           uninstall_property(element, 'reportValidity');\\n                           uninstall_property(element, 'setCustomValidity');\\n                           uninstall_property(element, 'stepDown');\\n                           uninstall_property(element, 'stepUp');\\n                           uninstall_property(element, 'validationMessage');\\n                           uninstall_property(element, 'validity');\\n                           uninstall_property(element, 'valueAsDate');\\n                           uninstall_property(element, 'valueAsNumber');\\n                           uninstall_property(element, 'willValidate');\\n\\n                           uninstall_properties(element);\\n                         } else if (element instanceof window.HTMLFormElement) {\\n                           uninstall_property(element, 'checkValidity');\\n                           uninstall_property(element, 'reportValidity');\\n                         }\\n                       }\\n\\n                       var instances = new WeakMap();\\n\\n                       /**\\n                        * wrap <form>s, window or document, that get treated with the global\\n                        * hyperform()\\n                        */\\n                       function Wrapper(form, settings) {\\n\\n                         /* do not allow more than one instance per form. Otherwise we'd end\\n                          * up with double event handlers, polyfills re-applied, ... */\\n                         var existing = instances.get(form);\\n                         if (existing) {\\n                           existing.settings = settings;\\n                           return existing;\\n                         }\\n\\n                         this.form = form;\\n                         this.settings = settings;\\n                         this.revalidator = this.revalidate.bind(this);\\n\\n                         instances.set(form, this);\\n\\n                         catch_submit(form, settings.revalidate === 'never');\\n\\n                         if (form === window || form.nodeType === 9) {\\n                           /* install on the prototypes, when called for the whole document */\\n                           this.install([window.HTMLButtonElement.prototype, window.HTMLInputElement.prototype, window.HTMLSelectElement.prototype, window.HTMLTextAreaElement.prototype, window.HTMLFieldSetElement.prototype]);\\n                           polyfill(window.HTMLFormElement);\\n                         } else if (form instanceof window.HTMLFormElement || form instanceof window.HTMLFieldSetElement) {\\n                           this.install(form.elements);\\n                           if (form instanceof window.HTMLFormElement) {\\n                             polyfill(form);\\n                           }\\n                         }\\n\\n                         if (settings.revalidate === 'oninput' || settings.revalidate === 'hybrid') {\\n                           /* in a perfect world we'd just bind to \\\"input\\\", but support here is\\n                            * abysmal: http://caniuse.com/#feat=input-event */\\n                           form.addEventListener('keyup', this.revalidator);\\n                           form.addEventListener('change', this.revalidator);\\n                         }\\n                         if (settings.revalidate === 'onblur' || settings.revalidate === 'hybrid') {\\n                           /* useCapture=true, because `blur` doesn't bubble. See\\n                            * https://developer.mozilla.org/en-US/docs/Web/Events/blur#Event_delegation\\n                            * for a discussion */\\n                           form.addEventListener('blur', this.revalidator, true);\\n                         }\\n                       }\\n\\n                       Wrapper.prototype = {\\n                         destroy: function destroy() {\\n                           uncatch_submit(this.form);\\n                           instances.delete(this.form);\\n                           this.form.removeEventListener('keyup', this.revalidator);\\n                           this.form.removeEventListener('change', this.revalidator);\\n                           this.form.removeEventListener('blur', this.revalidator, true);\\n                           if (this.form === window || this.form.nodeType === 9) {\\n                             this.uninstall([window.HTMLButtonElement.prototype, window.HTMLInputElement.prototype, window.HTMLSelectElement.prototype, window.HTMLTextAreaElement.prototype, window.HTMLFieldSetElement.prototype]);\\n                             polyunfill(window.HTMLFormElement);\\n                           } else if (this.form instanceof window.HTMLFormElement || this.form instanceof window.HTMLFieldSetElement) {\\n                             this.uninstall(this.form.elements);\\n                             if (this.form instanceof window.HTMLFormElement) {\\n                               polyunfill(this.form);\\n                             }\\n                           }\\n                         },\\n\\n\\n                         /**\\n                          * revalidate an input element\\n                          */\\n                         revalidate: function revalidate(event) {\\n                           if (event.target instanceof window.HTMLButtonElement || event.target instanceof window.HTMLTextAreaElement || event.target instanceof window.HTMLSelectElement || event.target instanceof window.HTMLInputElement) {\\n\\n                             if (this.settings.revalidate === 'hybrid') {\\n                               /* \\\"hybrid\\\" somewhat simulates what browsers do. See for example\\n                                * Firefox's :-moz-ui-invalid pseudo-class:\\n                                * https://developer.mozilla.org/en-US/docs/Web/CSS/:-moz-ui-invalid */\\n                               if (event.type === 'blur' && event.target.value !== event.target.defaultValue || ValidityState(event.target).valid) {\\n                                 /* on blur, update the report when the value has changed from the\\n                                  * default or when the element is valid (possibly removing a still\\n                                  * standing invalidity report). */\\n                                 reportValidity(event.target);\\n                               } else if (event.type === 'keyup' || event.type === 'change') {\\n                                 if (ValidityState(event.target).valid) {\\n                                   // report instantly, when an element becomes valid,\\n                                   // postpone report to blur event, when an element is invalid\\n                                   reportValidity(event.target);\\n                                 }\\n                               }\\n                             } else {\\n                               reportValidity(event.target);\\n                             }\\n                           }\\n                         },\\n\\n\\n                         /**\\n                          * install the polyfills on each given element\\n                          *\\n                          * If you add elements dynamically, you have to call install() on them\\n                          * yourself:\\n                          *\\n                          * js> var form = hyperform(document.forms[0]);\\n                          * js> document.forms[0].appendChild(input);\\n                          * js> form.install(input);\\n                          *\\n                          * You can skip this, if you called hyperform on window or document.\\n                          */\\n                         install: function install(els) {\\n                           if (els instanceof window.Element) {\\n                             els = [els];\\n                           }\\n\\n                           var els_length = els.length;\\n\\n                           for (var i = 0; i < els_length; i++) {\\n                             polyfill(els[i]);\\n                           }\\n                         },\\n                         uninstall: function uninstall(els) {\\n                           if (els instanceof window.Element) {\\n                             els = [els];\\n                           }\\n\\n                           var els_length = els.length;\\n\\n                           for (var i = 0; i < els_length; i++) {\\n                             polyunfill(els[i]);\\n                           }\\n                         }\\n                       };\\n\\n                       /**\\n                        * try to get the appropriate wrapper for a specific element by looking up\\n                        * its parent chain\\n                        *\\n                        * @return Wrapper | undefined\\n                        */\\n                       function get_wrapper(element) {\\n                         var wrapped;\\n\\n                         if (element.form) {\\n                           /* try a shortcut with the element's <form> */\\n                           wrapped = instances.get(element.form);\\n                         }\\n\\n                         /* walk up the parent nodes until document (including) */\\n                         while (!wrapped && element) {\\n                           wrapped = instances.get(element);\\n                           element = element.parentNode;\\n                         }\\n\\n                         if (!wrapped) {\\n                           /* try the global instance, if exists. This may also be undefined. */\\n                           wrapped = instances.get(window);\\n                         }\\n\\n                         return wrapped;\\n                       }\\n\\n                       /**\\n                        * check if an element is a candidate for constraint validation\\n                        *\\n                        * @see https://html.spec.whatwg.org/multipage/forms.html#barred-from-constraint-validation\\n                        */\\n                       function is_validation_candidate (element) {\\n\\n                         /* allow a shortcut via filters, e.g. to validate type=hidden fields */\\n                         var filtered = do_filter('is_validation_candidate', null, element);\\n                         if (filtered !== null) {\\n                           return !!filtered;\\n                         }\\n\\n                         /* it must be any of those elements */\\n                         if (element instanceof window.HTMLSelectElement || element instanceof window.HTMLTextAreaElement || element instanceof window.HTMLButtonElement || element instanceof window.HTMLInputElement) {\\n\\n                           var type = get_type(element);\\n                           /* its type must be in the whitelist or missing (select, textarea) */\\n                           if (!type || non_inputs.indexOf(type) > -1 || validation_candidates.indexOf(type) > -1) {\\n\\n                             /* it mustn't be disabled or readonly */\\n                             if (!element.hasAttribute('disabled') && !element.hasAttribute('readonly')) {\\n\\n                               var wrapped_form = get_wrapper(element);\\n                               /* it hasn't got the (non-standard) attribute 'novalidate' or its\\n                                * parent form has got the strict parameter */\\n                               if (wrapped_form && wrapped_form.settings.novalidateOnElements || !element.hasAttribute('novalidate') || !element.noValidate) {\\n\\n                                 /* it isn't part of a <fieldset disabled> */\\n                                 var p = element.parentNode;\\n                                 while (p && p.nodeType === 1) {\\n                                   if (p instanceof window.HTMLFieldSetElement && p.hasAttribute('disabled')) {\\n                                     /* quick return, if it's a child of a disabled fieldset */\\n                                     return false;\\n                                   } else if (p.nodeName.toUpperCase() === 'DATALIST') {\\n                                     /* quick return, if it's a child of a datalist\\n                                      * Do not use HTMLDataListElement to support older browsers,\\n                                      * too.\\n                                      * @see https://html.spec.whatwg.org/multipage/forms.html#the-datalist-element:barred-from-constraint-validation\\n                                      */\\n                                     return false;\\n                                   } else if (p === element.form) {\\n                                     /* the outer boundary. We can stop looking for relevant\\n                                      * fieldsets. */\\n                                     break;\\n                                   }\\n                                   p = p.parentNode;\\n                                 }\\n\\n                                 /* then it's a candidate */\\n                                 return true;\\n                               }\\n                             }\\n                           }\\n                         }\\n\\n                         /* this is no HTML5 validation candidate... */\\n                         return false;\\n                       }\\n\\n                       function format_date (date) {\\n                         var part = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\\n\\n                         switch (part) {\\n                           case 'date':\\n                             return (date.toLocaleDateString || date.toDateString).call(date);\\n                           case 'time':\\n                             return (date.toLocaleTimeString || date.toTimeString).call(date);\\n                           case 'month':\\n                             return 'toLocaleDateString' in date ? date.toLocaleDateString(undefined, {\\n                               year: 'numeric',\\n                               month: '2-digit'\\n                             }) : date.toDateString();\\n                           // case 'week':\\n                           // TODO\\n                           default:\\n                             return (date.toLocaleString || date.toString).call(date);\\n                         }\\n                       }\\n\\n                       /**\\n                        * patch String.length to account for non-BMP characters\\n                        *\\n                        * @see https://mathiasbynens.be/notes/javascript-unicode\\n                        * We do not use the simple [...str].length, because it needs a ton of\\n                        * polyfills in older browsers.\\n                        */\\n\\n                       function unicode_string_length (str) {\\n                         return str.match(/[\\\\0-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF]/g).length;\\n                       }\\n\\n                       /**\\n                        * internal storage for custom error messages\\n                        */\\n\\n                       var store$1 = new WeakMap();\\n\\n                       /**\\n                        * register custom error messages per element\\n                        */\\n                       var custom_messages = {\\n                         set: function set(element, validator, message) {\\n                           var messages = store$1.get(element) || {};\\n                           messages[validator] = message;\\n                           store$1.set(element, messages);\\n                           return custom_messages;\\n                         },\\n                         get: function get(element, validator) {\\n                           var _default = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\\n\\n                           var messages = store$1.get(element);\\n                           if (messages === undefined || !(validator in messages)) {\\n                             var data_id = 'data-' + validator.replace(/[A-Z]/g, '-$&').toLowerCase();\\n                             if (element.hasAttribute(data_id)) {\\n                               /* if the element has a data-validator attribute, use this as fallback.\\n                                * E.g., if validator == 'valueMissing', the element can specify a\\n                                * custom validation message like this:\\n                                *     <input data-value-missing=\\\"Oh noes!\\\">\\n                                */\\n                               return element.getAttribute(data_id);\\n                             }\\n                             return _default;\\n                           }\\n                           return messages[validator];\\n                         },\\n                         delete: function _delete(element) {\\n                           var validator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\\n\\n                           if (!validator) {\\n                             return store$1.delete(element);\\n                           }\\n                           var messages = store$1.get(element) || {};\\n                           if (validator in messages) {\\n                             delete messages[validator];\\n                             store$1.set(element, messages);\\n                             return true;\\n                           }\\n                           return false;\\n                         }\\n                       };\\n\\n                       var internal_registry = new WeakMap();\\n\\n                       /**\\n                        * A registry for custom validators\\n                        *\\n                        * slim wrapper around a WeakMap to ensure the values are arrays\\n                        * (hence allowing > 1 validators per element)\\n                        */\\n                       var custom_validator_registry = {\\n                         set: function set(element, validator) {\\n                           var current = internal_registry.get(element) || [];\\n                           current.push(validator);\\n                           internal_registry.set(element, current);\\n                           return custom_validator_registry;\\n                         },\\n                         get: function get(element) {\\n                           return internal_registry.get(element) || [];\\n                         },\\n                         delete: function _delete(element) {\\n                           return internal_registry.delete(element);\\n                         }\\n                       };\\n\\n                       /**\\n                        * test whether the element suffers from bad input\\n                        */\\n                       function test_bad_input (element) {\\n                         var type = get_type(element);\\n\\n                         if (!is_validation_candidate(element) || input_checked.indexOf(type) === -1) {\\n                           /* we're not interested, thanks! */\\n                           return true;\\n                         }\\n\\n                         /* the browser hides some bad input from the DOM, e.g. malformed numbers,\\n                          * email addresses with invalid punycode representation, ... We try to resort\\n                          * to the original method here. The assumption is, that a browser hiding\\n                          * bad input will hopefully also always support a proper\\n                          * ValidityState.badInput */\\n                         if (!element.value) {\\n                           if ('_original_validity' in element && !element._original_validity.__hyperform) {\\n                             return !element._original_validity.badInput;\\n                           }\\n                           /* no value and no original badInput: Assume all's right. */\\n                           return true;\\n                         }\\n\\n                         var result = true;\\n                         switch (type) {\\n                           case 'color':\\n                             result = /^#[a-f0-9]{6}$/.test(element.value);\\n                             break;\\n                           case 'number':\\n                           case 'range':\\n                             result = !isNaN(Number(element.value));\\n                             break;\\n                           case 'datetime':\\n                           case 'date':\\n                           case 'month':\\n                           case 'week':\\n                           case 'time':\\n                             result = string_to_date(element.value, type) !== null;\\n                             break;\\n                           case 'datetime-local':\\n                             result = /^([0-9]{4,})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9])(?::([0-5][0-9])(?:\\\\.([0-9]{1,3}))?)?$/.test(element.value);\\n                             break;\\n                           case 'tel':\\n                             /* spec says No! Phone numbers can have all kinds of formats, so this\\n                              * is expected to be a free-text field. */\\n                             // TODO we could allow a setting 'phone_regex' to be evaluated here.\\n                             break;\\n                           case 'email':\\n                             break;\\n                         }\\n\\n                         return result;\\n                       }\\n\\n                       /**\\n                        * test the max attribute\\n                        *\\n                        * we use Number() instead of parseFloat(), because an invalid attribute\\n                        * value like \\\"123abc\\\" should result in an error.\\n                        */\\n                       function test_max (element) {\\n                         var type = get_type(element);\\n\\n                         if (!is_validation_candidate(element) || !element.value || !element.hasAttribute('max')) {\\n                           /* we're not responsible here */\\n                           return true;\\n                         }\\n\\n                         var value = void 0,\\n                             max = void 0;\\n                         if (dates.indexOf(type) > -1) {\\n                           value = 1 * string_to_date(element.value, type);\\n                           max = 1 * (string_to_date(element.getAttribute('max'), type) || NaN);\\n                         } else {\\n                           value = Number(element.value);\\n                           max = Number(element.getAttribute('max'));\\n                         }\\n\\n                         return isNaN(max) || value <= max;\\n                       }\\n\\n                       /**\\n                        * test the maxlength attribute\\n                        */\\n                       function test_maxlength (element) {\\n                         if (!is_validation_candidate(element) || !element.value || text_types.indexOf(get_type(element)) === -1 || !element.hasAttribute('maxlength') || !element.getAttribute('maxlength') // catch maxlength=\\\"\\\"\\n                         ) {\\n                             return true;\\n                           }\\n\\n                         var maxlength = parseInt(element.getAttribute('maxlength'), 10);\\n\\n                         /* check, if the maxlength value is usable at all.\\n                          * We allow maxlength === 0 to basically disable input (Firefox does, too).\\n                          */\\n                         if (isNaN(maxlength) || maxlength < 0) {\\n                           return true;\\n                         }\\n\\n                         return unicode_string_length(element.value) <= maxlength;\\n                       }\\n\\n                       /**\\n                        * test the min attribute\\n                        *\\n                        * we use Number() instead of parseFloat(), because an invalid attribute\\n                        * value like \\\"123abc\\\" should result in an error.\\n                        */\\n                       function test_min (element) {\\n                         var type = get_type(element);\\n\\n                         if (!is_validation_candidate(element) || !element.value || !element.hasAttribute('min')) {\\n                           /* we're not responsible here */\\n                           return true;\\n                         }\\n\\n                         var value = void 0,\\n                             min = void 0;\\n                         if (dates.indexOf(type) > -1) {\\n                           value = 1 * string_to_date(element.value, type);\\n                           min = 1 * (string_to_date(element.getAttribute('min'), type) || NaN);\\n                         } else {\\n                           value = Number(element.value);\\n                           min = Number(element.getAttribute('min'));\\n                         }\\n\\n                         return isNaN(min) || value >= min;\\n                       }\\n\\n                       /**\\n                        * test the minlength attribute\\n                        */\\n                       function test_minlength (element) {\\n                         if (!is_validation_candidate(element) || !element.value || text_types.indexOf(get_type(element)) === -1 || !element.hasAttribute('minlength') || !element.getAttribute('minlength') // catch minlength=\\\"\\\"\\n                         ) {\\n                             return true;\\n                           }\\n\\n                         var minlength = parseInt(element.getAttribute('minlength'), 10);\\n\\n                         /* check, if the minlength value is usable at all. */\\n                         if (isNaN(minlength) || minlength < 0) {\\n                           return true;\\n                         }\\n\\n                         return unicode_string_length(element.value) >= minlength;\\n                       }\\n\\n                       /**\\n                        * test the pattern attribute\\n                        */\\n                       function test_pattern (element) {\\n                           return !is_validation_candidate(element) || !element.value || !element.hasAttribute('pattern') || new RegExp('^(?:' + element.getAttribute('pattern') + ')$').test(element.value);\\n                       }\\n\\n                       /**\\n                        * test the required attribute\\n                        */\\n                       function test_required (element) {\\n                         if (!is_validation_candidate(element) || !element.hasAttribute('required')) {\\n                           /* nothing to do */\\n                           return true;\\n                         }\\n\\n                         /* we don't need get_type() for element.type, because \\\"checkbox\\\" and \\\"radio\\\"\\n                          * are well supported. */\\n                         switch (element.type) {\\n                           case 'checkbox':\\n                             return element.checked;\\n                           //break;\\n                           case 'radio':\\n                             /* radio inputs have \\\"required\\\" fulfilled, if _any_ other radio\\n                              * with the same name in this form is checked. */\\n                             return !!(element.checked || element.form && Array.prototype.filter.call(document.getElementsByName(element.name), function (radio) {\\n                               return radio.name === element.name && radio.form === element.form && radio.checked;\\n                             }).length > 0);\\n                           //break;\\n                           default:\\n                             return !!element.value;\\n                         }\\n                       }\\n\\n                       /**\\n                        * test the step attribute\\n                        */\\n                       function test_step (element) {\\n                         var type = get_type(element);\\n\\n                         if (!is_validation_candidate(element) || !element.value || numbers.indexOf(type) === -1 || (element.getAttribute('step') || '').toLowerCase() === 'any') {\\n                           /* we're not responsible here. Note: If no step attribute is given, we\\n                            * need to validate against the default step as per spec. */\\n                           return true;\\n                         }\\n\\n                         var step = element.getAttribute('step');\\n                         if (step) {\\n                           step = string_to_number(step, type);\\n                         } else {\\n                           step = default_step[type] || 1;\\n                         }\\n\\n                         if (step <= 0 || isNaN(step)) {\\n                           /* error in specified \\\"step\\\". We cannot validate against it, so the value\\n                            * is true. */\\n                           return true;\\n                         }\\n\\n                         var scale = step_scale_factor[type] || 1;\\n\\n                         var value = string_to_number(element.value, type);\\n                         var min = string_to_number(element.getAttribute('min') || element.getAttribute('value') || '', type);\\n\\n                         if (isNaN(min)) {\\n                           min = default_step_base[type] || 0;\\n                         }\\n\\n                         if (type === 'month') {\\n                           /* type=month has month-wide steps. See\\n                            * https://html.spec.whatwg.org/multipage/forms.html#month-state-%28type=month%29\\n                            */\\n                           min = new Date(min).getUTCFullYear() * 12 + new Date(min).getUTCMonth();\\n                           value = new Date(value).getUTCFullYear() * 12 + new Date(value).getUTCMonth();\\n                         }\\n\\n                         var result = Math.abs(min - value) % (step * scale);\\n\\n                         return result < 0.00000001 ||\\n                         /* crappy floating-point arithmetics! */\\n                         result > step * scale - 0.00000001;\\n                       }\\n\\n                       var ws_on_start_or_end = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g;\\n\\n                       /**\\n                        * trim a string of whitespace\\n                        *\\n                        * We don't use String.trim() to remove the need to polyfill it.\\n                        */\\n                       function trim (str) {\\n                         return str.replace(ws_on_start_or_end, '');\\n                       }\\n\\n                       /**\\n                        * split a string on comma and trim the components\\n                        *\\n                        * As specified at\\n                        * https://html.spec.whatwg.org/multipage/infrastructure.html#split-a-string-on-commas\\n                        * plus removing empty entries.\\n                        */\\n                       function comma_split (str) {\\n                         return str.split(',').map(function (item) {\\n                           return trim(item);\\n                         }).filter(function (b) {\\n                           return b;\\n                         });\\n                       }\\n\\n                       /* we use a dummy <a> where we set the href to test URL validity\\n                        * The definition is out of the \\\"global\\\" scope so that JSDOM can be instantiated\\n                        * after loading Hyperform for tests.\\n                        */\\n                       var url_canary;\\n\\n                       /* see https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address */\\n                       var email_pattern = /^[a-zA-Z0-9.!#$%&'*+\\\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\\n\\n                       /**\\n                        * test the type-inherent syntax\\n                        */\\n                       function test_type (element) {\\n                         var type = get_type(element);\\n\\n                         if (!is_validation_candidate(element) || type !== 'file' && !element.value || type !== 'file' && type_checked.indexOf(type) === -1) {\\n                           /* we're not responsible for this element */\\n                           return true;\\n                         }\\n\\n                         var is_valid = true;\\n\\n                         switch (type) {\\n                           case 'url':\\n                             if (!url_canary) {\\n                               url_canary = document.createElement('a');\\n                             }\\n                             var value = trim(element.value);\\n                             url_canary.href = value;\\n                             is_valid = url_canary.href === value || url_canary.href === value + '/';\\n                             break;\\n                           case 'email':\\n                             if (element.hasAttribute('multiple')) {\\n                               is_valid = comma_split(element.value).every(function (value) {\\n                                 return email_pattern.test(value);\\n                               });\\n                             } else {\\n                               is_valid = email_pattern.test(trim(element.value));\\n                             }\\n                             break;\\n                           case 'file':\\n                             if ('files' in element && element.files.length && element.hasAttribute('accept')) {\\n                               var patterns = comma_split(element.getAttribute('accept')).map(function (pattern) {\\n                                 if (/^(audio|video|image)\\\\/\\\\*$/.test(pattern)) {\\n                                   pattern = new RegExp('^' + RegExp.$1 + '/.+$');\\n                                 }\\n                                 return pattern;\\n                               });\\n\\n                               if (!patterns.length) {\\n                                 break;\\n                               }\\n\\n                               fileloop: for (var i = 0; i < element.files.length; i++) {\\n                                 /* we need to match a whitelist, so pre-set with false */\\n                                 var file_valid = false;\\n\\n                                 patternloop: for (var j = 0; j < patterns.length; j++) {\\n                                   var file = element.files[i];\\n                                   var pattern = patterns[j];\\n\\n                                   var fileprop = file.type;\\n\\n                                   if (typeof pattern === 'string' && pattern.substr(0, 1) === '.') {\\n                                     if (file.name.search('.') === -1) {\\n                                       /* no match with any file ending */\\n                                       continue patternloop;\\n                                     }\\n\\n                                     fileprop = file.name.substr(file.name.lastIndexOf('.'));\\n                                   }\\n\\n                                   if (fileprop.search(pattern) === 0) {\\n                                     /* we found one match and can quit looking */\\n                                     file_valid = true;\\n                                     break patternloop;\\n                                   }\\n                                 }\\n\\n                                 if (!file_valid) {\\n                                   is_valid = false;\\n                                   break fileloop;\\n                                 }\\n                               }\\n                             }\\n                         }\\n\\n                         return is_valid;\\n                       }\\n\\n                       /**\\n                        * boilerplate function for all tests but customError\\n                        */\\n                       function check$1(test, react) {\\n                         return function (element) {\\n                           var invalid = !test(element);\\n                           if (invalid) {\\n                             react(element);\\n                           }\\n                           return invalid;\\n                         };\\n                       }\\n\\n                       /**\\n                        * create a common function to set error messages\\n                        */\\n                       function set_msg(element, msgtype, _default) {\\n                         message_store.set(element, custom_messages.get(element, msgtype, _default));\\n                       }\\n\\n                       var badInput = check$1(test_bad_input, function (element) {\\n                         return set_msg(element, 'badInput', _('Please match the requested type.'));\\n                       });\\n\\n                       function customError(element) {\\n                         /* check, if there are custom validators in the registry, and call\\n                          * them. */\\n                         var custom_validators = custom_validator_registry.get(element);\\n                         var cvl = custom_validators.length;\\n                         var valid = true;\\n\\n                         if (cvl) {\\n                           for (var i = 0; i < cvl; i++) {\\n                             var result = custom_validators[i](element);\\n                             if (result !== undefined && !result) {\\n                               valid = false;\\n                               /* break on first invalid response */\\n                               break;\\n                             }\\n                           }\\n                         }\\n\\n                         /* check, if there are other validity messages already */\\n                         if (valid) {\\n                           var msg = message_store.get(element);\\n                           valid = !(msg.toString() && 'is_custom' in msg);\\n                         }\\n\\n                         return !valid;\\n                       }\\n\\n                       var patternMismatch = check$1(test_pattern, function (element) {\\n                         set_msg(element, 'patternMismatch', element.title ? sprintf(_('PatternMismatchWithTitle'), element.title) : _('PatternMismatch'));\\n                       });\\n\\n                       /**\\n                        * TODO: when rangeOverflow and rangeUnderflow are both called directly and\\n                        * successful, the inRange and outOfRange classes won't get removed, unless\\n                        * element.validityState.valid is queried, too.\\n                        */\\n                       var rangeOverflow = check$1(test_max, function (element) {\\n                         var type = get_type(element);\\n                         var wrapper = get_wrapper(element);\\n                         var outOfRangeClass = wrapper && wrapper.settings.classes.outOfRange || 'hf-out-of-range';\\n                         var inRangeClass = wrapper && wrapper.settings.classes.inRange || 'hf-in-range';\\n\\n                         var msg = void 0;\\n\\n                         switch (type) {\\n                           case 'date':\\n                           case 'datetime':\\n                           case 'datetime-local':\\n                             msg = sprintf(_('DateRangeOverflow'), format_date(string_to_date(element.getAttribute('max'), type), type));\\n                             break;\\n                           case 'time':\\n                             msg = sprintf(_('TimeRangeOverflow'), format_date(string_to_date(element.getAttribute('max'), type), type));\\n                             break;\\n                           // case 'number':\\n                           default:\\n                             msg = sprintf(_('NumberRangeOverflow'), string_to_number(element.getAttribute('max'), type));\\n                             break;\\n                         }\\n\\n                         set_msg(element, 'rangeOverflow', msg);\\n                         element.classList.add(outOfRangeClass);\\n                         element.classList.remove(inRangeClass);\\n                       });\\n\\n                       var rangeUnderflow = check$1(test_min, function (element) {\\n                         var type = get_type(element);\\n                         var wrapper = get_wrapper(element);\\n                         var outOfRangeClass = wrapper && wrapper.settings.classes.outOfRange || 'hf-out-of-range';\\n                         var inRangeClass = wrapper && wrapper.settings.classes.inRange || 'hf-in-range';\\n\\n                         var msg = void 0;\\n\\n                         switch (type) {\\n                           case 'date':\\n                           case 'datetime':\\n                           case 'datetime-local':\\n                             msg = sprintf(_('DateRangeUnderflow'), format_date(string_to_date(element.getAttribute('min'), type), type));\\n                             break;\\n                           case 'time':\\n                             msg = sprintf(_('TimeRangeUnderflow'), format_date(string_to_date(element.getAttribute('min'), type), type));\\n                             break;\\n                           // case 'number':\\n                           default:\\n                             msg = sprintf(_('NumberRangeUnderflow'), string_to_number(element.getAttribute('min'), type));\\n                             break;\\n                         }\\n\\n                         set_msg(element, 'rangeUnderflow', msg);\\n                         element.classList.add(outOfRangeClass);\\n                         element.classList.remove(inRangeClass);\\n                       });\\n\\n                       var stepMismatch = check$1(test_step, function (element) {\\n                         var list = get_next_valid(element);\\n                         var min = list[0];\\n                         var max = list[1];\\n                         var sole = false;\\n                         var msg = void 0;\\n\\n                         if (min === null) {\\n                           sole = max;\\n                         } else if (max === null) {\\n                           sole = min;\\n                         }\\n\\n                         if (sole !== false) {\\n                           msg = sprintf(_('StepMismatchOneValue'), sole);\\n                         } else {\\n                           msg = sprintf(_('StepMismatch'), min, max);\\n                         }\\n                         set_msg(element, 'stepMismatch', msg);\\n                       });\\n\\n                       var tooLong = check$1(test_maxlength, function (element) {\\n                         set_msg(element, 'tooLong', sprintf(_('TextTooLong'), element.getAttribute('maxlength'), unicode_string_length(element.value)));\\n                       });\\n\\n                       var tooShort = check$1(test_minlength, function (element) {\\n                         set_msg(element, 'tooShort', sprintf(_('Please lengthen this text to %l characters or more (you are currently using %l characters).'), element.getAttribute('minlength'), unicode_string_length(element.value)));\\n                       });\\n\\n                       var typeMismatch = check$1(test_type, function (element) {\\n                         var msg = _('Please use the appropriate format.');\\n                         var type = get_type(element);\\n\\n                         if (type === 'email') {\\n                           if (element.hasAttribute('multiple')) {\\n                             msg = _('Please enter a comma separated list of email addresses.');\\n                           } else {\\n                             msg = _('InvalidEmail');\\n                           }\\n                         } else if (type === 'url') {\\n                           msg = _('InvalidURL');\\n                         } else if (type === 'file') {\\n                           msg = _('Please select a file of the correct type.');\\n                         }\\n\\n                         set_msg(element, 'typeMismatch', msg);\\n                       });\\n\\n                       var valueMissing = check$1(test_required, function (element) {\\n                         var msg = _('ValueMissing');\\n                         var type = get_type(element);\\n\\n                         if (type === 'checkbox') {\\n                           msg = _('CheckboxMissing');\\n                         } else if (type === 'radio') {\\n                           msg = _('RadioMissing');\\n                         } else if (type === 'file') {\\n                           if (element.hasAttribute('multiple')) {\\n                             msg = _('Please select one or more files.');\\n                           } else {\\n                             msg = _('FileMissing');\\n                           }\\n                         } else if (element instanceof window.HTMLSelectElement) {\\n                           msg = _('SelectMissing');\\n                         }\\n\\n                         set_msg(element, 'valueMissing', msg);\\n                       });\\n\\n                       var validity_state_checkers = {\\n                         badInput: badInput,\\n                         customError: customError,\\n                         patternMismatch: patternMismatch,\\n                         rangeOverflow: rangeOverflow,\\n                         rangeUnderflow: rangeUnderflow,\\n                         stepMismatch: stepMismatch,\\n                         tooLong: tooLong,\\n                         tooShort: tooShort,\\n                         typeMismatch: typeMismatch,\\n                         valueMissing: valueMissing\\n                       };\\n\\n                       /**\\n                        * the validity state constructor\\n                        */\\n                       var ValidityState = function ValidityState(element) {\\n                         if (!(element instanceof window.HTMLElement)) {\\n                           throw new Error('cannot create a ValidityState for a non-element');\\n                         }\\n\\n                         var cached = ValidityState.cache.get(element);\\n                         if (cached) {\\n                           return cached;\\n                         }\\n\\n                         if (!(this instanceof ValidityState)) {\\n                           /* working around a forgotten `new` */\\n                           return new ValidityState(element);\\n                         }\\n\\n                         this.element = element;\\n                         ValidityState.cache.set(element, this);\\n                       };\\n\\n                       /**\\n                        * the prototype for new validityState instances\\n                        */\\n                       var ValidityStatePrototype = {};\\n                       ValidityState.prototype = ValidityStatePrototype;\\n\\n                       ValidityState.cache = new WeakMap();\\n\\n                       /**\\n                        * copy functionality from the validity checkers to the ValidityState\\n                        * prototype\\n                        */\\n                       for (var prop in validity_state_checkers) {\\n                         Object.defineProperty(ValidityStatePrototype, prop, {\\n                           configurable: true,\\n                           enumerable: true,\\n                           get: function (func) {\\n                             return function () {\\n                               return func(this.element);\\n                             };\\n                           }(validity_state_checkers[prop]),\\n                           set: undefined\\n                         });\\n                       }\\n\\n                       /**\\n                        * the \\\"valid\\\" property calls all other validity checkers and returns true,\\n                        * if all those return false.\\n                        *\\n                        * This is the major access point for _all_ other API methods, namely\\n                        * (check|report)Validity().\\n                        */\\n                       Object.defineProperty(ValidityStatePrototype, 'valid', {\\n                         configurable: true,\\n                         enumerable: true,\\n                         get: function get() {\\n                           var wrapper = get_wrapper(this.element);\\n                           var validClass = wrapper && wrapper.settings.classes.valid || 'hf-valid';\\n                           var invalidClass = wrapper && wrapper.settings.classes.invalid || 'hf-invalid';\\n                           var userInvalidClass = wrapper && wrapper.settings.classes.userInvalid || 'hf-user-invalid';\\n                           var userValidClass = wrapper && wrapper.settings.classes.userValid || 'hf-user-valid';\\n                           var inRangeClass = wrapper && wrapper.settings.classes.inRange || 'hf-in-range';\\n                           var outOfRangeClass = wrapper && wrapper.settings.classes.outOfRange || 'hf-out-of-range';\\n                           var validatedClass = wrapper && wrapper.settings.classes.validated || 'hf-validated';\\n\\n                           this.element.classList.add(validatedClass);\\n\\n                           if (is_validation_candidate(this.element)) {\\n                             for (var _prop in validity_state_checkers) {\\n                               if (validity_state_checkers[_prop](this.element)) {\\n                                 this.element.classList.add(invalidClass);\\n                                 this.element.classList.remove(validClass);\\n                                 this.element.classList.remove(userValidClass);\\n                                 if (this.element.value !== this.element.defaultValue) {\\n                                   this.element.classList.add(userInvalidClass);\\n                                 } else {\\n                                   this.element.classList.remove(userInvalidClass);\\n                                 }\\n                                 this.element.setAttribute('aria-invalid', 'true');\\n                                 return false;\\n                               }\\n                             }\\n                           }\\n\\n                           message_store.delete(this.element);\\n                           this.element.classList.remove(invalidClass, userInvalidClass, outOfRangeClass);\\n                           this.element.classList.add(validClass, inRangeClass);\\n                           if (this.element.value !== this.element.defaultValue) {\\n                             this.element.classList.add(userValidClass);\\n                           } else {\\n                             this.element.classList.remove(userValidClass);\\n                           }\\n                           this.element.setAttribute('aria-invalid', 'false');\\n                           return true;\\n                         },\\n                         set: undefined\\n                       });\\n\\n                       /**\\n                        * mark the validity prototype, because that is what the client-facing\\n                        * code deals with mostly, not the property descriptor thing */\\n                       mark(ValidityStatePrototype);\\n\\n                       /**\\n                        * check an element's validity with respect to it's form\\n                        */\\n                       var checkValidity = return_hook_or('checkValidity', function (element) {\\n                         /* if this is a <form>, check validity of all child inputs */\\n                         if (element instanceof window.HTMLFormElement) {\\n                           return Array.prototype.map.call(element.elements, checkValidity).every(function (b) {\\n                             return b;\\n                           });\\n                         }\\n\\n                         /* default is true, also for elements that are no validation candidates */\\n                         var valid = ValidityState(element).valid;\\n                         if (valid) {\\n                           var wrapped_form = get_wrapper(element);\\n                           if (wrapped_form && wrapped_form.settings.validEvent) {\\n                             trigger_event(element, 'valid');\\n                           }\\n                         } else {\\n                           trigger_event(element, 'invalid', { cancelable: true });\\n                         }\\n\\n                         return valid;\\n                       });\\n\\n                       var version = '0.9.5';\\n\\n                       /* deprecate the old snake_case names\\n                        * TODO: delme before next non-patch release\\n                        */\\n                       function w(name) {\\n                         var deprecated_message = 'Please use camelCase method names! The name \\\"%s\\\" is deprecated and will be removed in the next non-patch release.';\\n                         /* global console */\\n                         console.log(sprintf(deprecated_message, name));\\n                       }\\n\\n                       /**\\n                        * public hyperform interface:\\n                        */\\n                       function hyperform(form) {\\n                         var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n                         var classes = _ref.classes;\\n                         var _ref$debug = _ref.debug;\\n                         var debug = _ref$debug === undefined ? false : _ref$debug;\\n                         var extend_fieldset = _ref.extend_fieldset;\\n                         var extendFieldset = _ref.extendFieldset;\\n                         var novalidate_on_elements = _ref.novalidate_on_elements;\\n                         var novalidateOnElements = _ref.novalidateOnElements;\\n                         var prevent_implicit_submit = _ref.prevent_implicit_submit;\\n                         var preventImplicitSubmit = _ref.preventImplicitSubmit;\\n                         var revalidate = _ref.revalidate;\\n                         var _ref$strict = _ref.strict;\\n                         var strict = _ref$strict === undefined ? false : _ref$strict;\\n                         var valid_event = _ref.valid_event;\\n                         var validEvent = _ref.validEvent;\\n\\n\\n                         if (!classes) {\\n                           classes = {};\\n                         }\\n                         // TODO: clean up before next non-patch release\\n                         if (extendFieldset === undefined) {\\n                           if (extend_fieldset === undefined) {\\n                             extendFieldset = !strict;\\n                           } else {\\n                             w('extend_fieldset');\\n                             extendFieldset = extend_fieldset;\\n                           }\\n                         }\\n                         if (novalidateOnElements === undefined) {\\n                           if (novalidate_on_elements === undefined) {\\n                             novalidateOnElements = !strict;\\n                           } else {\\n                             w('novalidate_on_elements');\\n                             novalidateOnElements = novalidate_on_elements;\\n                           }\\n                         }\\n                         if (preventImplicitSubmit === undefined) {\\n                           if (prevent_implicit_submit === undefined) {\\n                             preventImplicitSubmit = false;\\n                           } else {\\n                             w('prevent_implicit_submit');\\n                             preventImplicitSubmit = prevent_implicit_submit;\\n                           }\\n                         }\\n                         if (revalidate === undefined) {\\n                           /* other recognized values: 'oninput', 'onblur', 'onsubmit' and 'never' */\\n                           revalidate = strict ? 'onsubmit' : 'hybrid';\\n                         }\\n                         if (validEvent === undefined) {\\n                           if (valid_event === undefined) {\\n                             validEvent = !strict;\\n                           } else {\\n                             w('valid_event');\\n                             validEvent = valid_event;\\n                           }\\n                         }\\n\\n                         var settings = { debug: debug, strict: strict, preventImplicitSubmit: preventImplicitSubmit, revalidate: revalidate,\\n                           validEvent: validEvent, extendFieldset: extendFieldset, classes: classes };\\n\\n                         if (form instanceof window.NodeList || form instanceof window.HTMLCollection || form instanceof Array) {\\n                           return Array.prototype.map.call(form, function (element) {\\n                             return hyperform(element, settings);\\n                           });\\n                         }\\n\\n                         return new Wrapper(form, settings);\\n                       }\\n\\n                       hyperform.version = version;\\n\\n                       hyperform.checkValidity = checkValidity;\\n                       hyperform.reportValidity = reportValidity;\\n                       hyperform.setCustomValidity = setCustomValidity;\\n                       hyperform.stepDown = stepDown;\\n                       hyperform.stepUp = stepUp;\\n                       hyperform.validationMessage = validationMessage;\\n                       hyperform.ValidityState = ValidityState;\\n                       hyperform.valueAsDate = valueAsDate;\\n                       hyperform.valueAsNumber = valueAsNumber;\\n                       hyperform.willValidate = willValidate;\\n\\n                       hyperform.setLanguage = function (lang) {\\n                         set_language(lang);return hyperform;\\n                       };\\n                       hyperform.addTranslation = function (lang, catalog) {\\n                         add_translation(lang, catalog);return hyperform;\\n                       };\\n                       hyperform.setRenderer = function (renderer, action) {\\n                         Renderer.set(renderer, action);return hyperform;\\n                       };\\n                       hyperform.addValidator = function (element, validator) {\\n                         custom_validator_registry.set(element, validator);return hyperform;\\n                       };\\n                       hyperform.setMessage = function (element, validator, message) {\\n                         custom_messages.set(element, validator, message);return hyperform;\\n                       };\\n                       hyperform.addHook = function (hook, action, position) {\\n                         add_hook(hook, action, position);return hyperform;\\n                       };\\n                       hyperform.removeHook = function (hook, action) {\\n                         remove_hook(hook, action);return hyperform;\\n                       };\\n\\n                       // TODO: Remove in next non-patch version\\n                       hyperform.set_language = function (lang) {\\n                         w('set_language');set_language(lang);return hyperform;\\n                       };\\n                       hyperform.add_translation = function (lang, catalog) {\\n                         w('add_translation');add_translation(lang, catalog);return hyperform;\\n                       };\\n                       hyperform.set_renderer = function (renderer, action) {\\n                         w('set_renderer');Renderer.set(renderer, action);return hyperform;\\n                       };\\n                       hyperform.add_validator = function (element, validator) {\\n                         w('add_validator');custom_validator_registry.set(element, validator);return hyperform;\\n                       };\\n                       hyperform.set_message = function (element, validator, message) {\\n                         w('set_message');custom_messages.set(element, validator, message);return hyperform;\\n                       };\\n                       hyperform.add_hook = function (hook, action, position) {\\n                         w('add_hook');add_hook(hook, action, position);return hyperform;\\n                       };\\n                       hyperform.remove_hook = function (hook, action) {\\n                         w('remove_hook');remove_hook(hook, action);return hyperform;\\n                       };\\n\\n                       if (document.currentScript && document.currentScript.hasAttribute('data-hf-autoload')) {\\n                         hyperform(window);\\n                       }\\n\\n                       return hyperform;\\n\\n}());\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!./~/hyperform/dist/hyperform.js\n// module id = 10\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader/addScript.js\n// module id = 11\n// module chunks = 0","require(\"!!/Users/corjen/Projects/github/wordpress-boilerplate/node_modules/script-loader/addScript.js\")(require(\"!!/Users/corjen/Projects/github/wordpress-boilerplate/node_modules/raw-loader/index.js!/Users/corjen/Projects/github/wordpress-boilerplate/node_modules/hyperform/dist/hyperform.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader!./~/hyperform/dist/hyperform.js\n// module id = 12\n// module chunks = 0"],"sourceRoot":""}